<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lecon</title>
  
  
  <link href="https://leconio.github.io/atom.xml" rel="self"/>
  
  <link href="https://leconio.github.io/"/>
  <updated>2021-03-04T05:58:31.302Z</updated>
  <id>https://leconio.github.io/</id>
  
  <author>
    <name>lecon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 系统启动原理图</title>
    <link href="https://leconio.github.io/2021/03/04/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    <id>https://leconio.github.io/2021/03/04/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%9B%BE/</id>
    <published>2021-03-04T13:55:09.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>Android 系统启动原理图</p><span id="more"></span><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/android-qi-dong.png" alt="Android 启动"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android 系统启动原理图&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://leconio.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Binder 通信原理图</title>
    <link href="https://leconio.github.io/2021/03/04/Binder-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    <id>https://leconio.github.io/2021/03/04/Binder-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%9B%BE/</id>
    <published>2021-03-04T13:48:59.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>Binder 通信原理图</p><span id="more"></span><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/binder-tong-xin-yuan-li-tu.png" alt="Binder 通信原理图"></p><ol><li>Binder 驱动在内核空间创建一个数据接收缓存区。</li><li>进程在内核空间开辟一个内核缓存区，建立与数据接收缓存区的映射。同时建立数据缓存区与接收进程用户空间地址的映射关系</li><li>发送方调用 copy_from_user() 函数将数据复制到内核缓存区，等于把数据复制到了接收进程</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Binder 通信原理图&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://leconio.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle依赖中关于Maven和源码依赖的一个问题</title>
    <link href="https://leconio.github.io/2021/03/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%AD%E5%85%B3%E4%BA%8EMaven%E5%92%8C%E6%BA%90%E7%A0%81%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://leconio.github.io/2021/03/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%AD%E5%85%B3%E4%BA%8EMaven%E5%92%8C%E6%BA%90%E7%A0%81%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-04T10:07:21.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>不同的依赖方式可以组合使用，但他们组合使用时候坑确实很多</p><span id="more"></span><p>Java 的常用的依赖方式通常有三种，即 Maven，jar（aar）包，和源码依赖，不同的依赖方式可以组合使用，但他们组合使用时候坑确实很多，下面我们就讨论集中比较常见的情况，这也是我们开发者在进行多模块开发时候会遇到的问题。</p><p>在进行多模块开发过程中，我们通常把经常需要变动的业务模块使用源码依赖的方式进行依赖，如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">api project(<span class="string">&quot;:mavenlibrary2&quot;</span>)</span><br><span class="line">implementation project(<span class="string">&quot;:mavenlibrary2&quot;</span>)</span><br></pre></td></tr></table></figure><p>而公共库以及很少变动的模块，通常使用 Maven 方式进行依赖，如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;io.lecon.app:depdemo:1.0.0&#x27;</span></span><br></pre></td></tr></table></figure><p>想法是非常好的，但是实际开发过程中，随着代码量的增大就显得不是那么回事儿了。业务模块还好说，都是源码依赖方式，基本上不会出现什么问题。但是在使用 Maven 进行依赖的公共库模块就发生了问题。下面看一种情况：</p><p>业务模块正常依赖这个不用管，但是公共模块中同样很多模块进行开发。这时候我们业务模块使用 Maven 的方式对公共模块进行依赖，那么公共模块的各个子模块之间的依赖方式是什么呢？Maven，源码？这样说你可能不好理解，如下图所示:<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/16148236172274.jpg"><br>先说答案，<strong>只能使用 Maven 的方式依赖</strong><br>Maven 在进行打包的时候，不会将源码依赖的子功能打包进去，但是会保存依赖信息。如果你确实这么做了的话，也许会遇到这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Failed to resolve: AppLibrary:mavenlibrary2:unspecified</span><br></pre></td></tr></table></figure><p>在进行公共模块开发时候，可以使用源码的方式进行依赖，但是最后放到业务里面运行的时候，公共模块的所有子模块之间一定要全部使用 Maven 方式进行依赖。</p><p>但是这样就会出现一个问题，不同的模块版本号之间如何保持一致？<br>其实这是一个很严重的问题，不同版本之间开放的 api 很有可能不一样，而这些问题在编译时候不一定会报出来，也就是说在运行时会发生类找不到的问题。所以在要把所有 Maven 依赖的项目的版本号以及依赖顺序要统一管理起来，这个话题下次再说。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同的依赖方式可以组合使用，但他们组合使用时候坑确实很多&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://leconio.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>一步一步使用Android调用Golang</title>
    <link href="https://leconio.github.io/2021/03/04/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8Android%E8%B0%83%E7%94%A8Golang/"/>
    <id>https://leconio.github.io/2021/03/04/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8Android%E8%B0%83%E7%94%A8Golang/</id>
    <published>2021-03-04T10:05:09.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><span id="more"></span><h2 id="前提需要了解的"><a href="#前提需要了解的" class="headerlink" title="前提需要了解的"></a>前提需要了解的</h2><ol><li><p>在 Android 中运行 go 代码，需要用到一个工具<code>gomobile</code>，后面会说到安装方式。</p></li><li><p>Go 开发环境，配置好 GOPATH 和 GOROOT 等。</p></li><li><p>AndroidSDK 和 AndroidNDK</p></li></ol><h2 id="准备好-Go-代码"><a href="#准备好-Go-代码" class="headerlink" title="准备好 Go 代码"></a>准备好 Go 代码</h2><p>首先要准备好 GO 的开发坏境，并且配置好 GOPATH，咱们的项目叫<code>mobilego</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir code/mobilego</span><br><span class="line">cd code/mobilego</span><br><span class="line">echo export GOPATH=\$GOPATH:$(pwd) &gt;&gt; ~/.zshrc # .zshrc 为你的bash地址</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>其中<code>code/mobilego</code>是咱们 go 项目地址。那么现在就可以准备 go 代码了，那么我们可以按照这个样子新建一个项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mobilego</span><br><span class="line">└── src</span><br><span class="line">    └── mobile</span><br><span class="line">        └── mobile.go</span><br></pre></td></tr></table></figure><p>其中，src 目录是必须要有的，因为 gomobile 需要从这个路径下查找包。其中<code>mobile.go</code>代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mobile</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello Mobile&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHelloWithParams</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHelloWithParamsAndReturn</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHelloWithParamsAndReturnAndException</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">error)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span> + name, fmt.Errorf(<span class="string">&quot;some error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>mobile.go</code>就是 java 和 go 文件通信的入口，其中 gomobile 会把这个文件的包名，编译成 java 对应符合 java 命名规范的类名（<code>Mobile</code>）。</p><p><code>mobile.go</code>通过四个例子来演示 java 和 go 的通信。其中第一个无参数无返回值；第二个有参数无返回值；第三个有参数有返回值（同步返回）；第四个有参数有返回值并且抛出一个异常。由于 java 不支持多返回值，如果 go 使用多个返回值的话，会报出错误。</p><h2 id="准备-gomobile"><a href="#准备-gomobile" class="headerlink" title="准备 gomobile"></a>准备 gomobile</h2><p>gomobile 是一个可以为 go 编译成 android 和 ios 平台使用的工具，他的使用说明在<code>https://github.com/golang/go/wiki/Mobile#tools</code>可以找到。</p><ol><li>首先下载这个工具</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org&#x2F;x&#x2F;mobile&#x2F;cmd&#x2F;gomobile</span><br></pre></td></tr></table></figure><p>golang.org 的代码基本上都托管在 google 服务器，一般来说在国内都不会下载成功的。那么只好换成另外一种下载方式。在这里，我们把<code> golang.org/x/mobile/cmd/gomobile</code>中的<code>golang.org/x/</code>换成<code>github.com/golang/</code>。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;golang&#x2F;mobile&#x2F;cmd&#x2F;gomobile</span><br></pre></td></tr></table></figure><p>这时候你会发现，这个包下载到了 GOPATH/github.com 下面了。我们要把它拷贝到 golang.org 目录下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv $GOPATH&#x2F;src&#x2F;github.com&#x2F;golang&#x2F;mobile $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;mobile</span><br></pre></td></tr></table></figure><p>然后重新执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org&#x2F;x&#x2F;mobile&#x2F;cmd&#x2F;gomobile</span><br></pre></td></tr></table></figure><p>不出意外，gomobile 已经安装完成了。执行<code>gomobile version</code>检查一下是否安装成功。</p><h2 id="编译-go-代码"><a href="#编译-go-代码" class="headerlink" title="编译 go 代码"></a>编译 go 代码</h2><p>这一步要把 go 代码编译成 Android 平台使用的机器码。gomobile 是一个非常好用的工具，通过一个命令不仅能把 go 代码编译成平台码，同时还会使用 aar 包来包装它，也就是说，我们完全不用写恶心的 native 代码了，直接调用 gomobile 生成的 Java 代码就好了。</p><p>首先来到 go 项目目录下面，执行 gomobile 编译命令。gomobile 需要 NDK，再次确定一下是否安装 NDK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gomobile bind -target&#x3D;android mobile.go</span><br></pre></td></tr></table></figure><p><code>mobile.go</code>为入口文件。如果没什么问题的话，在项目目录下面就会多出两个文件。<code>mobile.aar</code>和<code>mobile-sources.jar</code>。其中<code>mobile.aar</code>就是我们编译完成的文件。</p><h2 id="Android-调用-Go"><a href="#Android-调用-Go" class="headerlink" title="Android 调用 Go"></a>Android 调用 Go</h2><p>把上面的生成的<code>mobile.aar</code>拷贝到 Android 项目中的 lib 下面，同时修改<code>build.gradle</code>，在 dependencies 中加入或者修改一下代码，</p><p><strong>默认值：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</span><br></pre></td></tr></table></figure><p><strong>修改后：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;,&#39;*.aar&#39;])</span><br></pre></td></tr></table></figure><p>Sync 一下工程，通过 Java 测试一下我们的 go 代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">Void, Void, Any?</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInBackground</span><span class="params">(<span class="keyword">vararg</span> params: <span class="type">Void</span>)</span></span>: Any? &#123;</span><br><span class="line">        Mobile.sayHello()</span><br><span class="line">        Mobile.sayHelloWithParams(<span class="string">&quot;lecon&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = Mobile.sayHelloWithParamsAndReturn(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;AndroidGo&quot;</span>,result)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Mobile.sayHelloWithParamsAndReturnAndException(<span class="string">&quot;liucl&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e:Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-18 13:31:04.566 7925-7982&#x2F;? D&#x2F;AndroidGo: Hellospawn</span><br><span class="line">2019-04-18 13:31:04.571 7925-7982&#x2F;? W&#x2F;System.err:     at mobile.Mobile.sayHelloWithParamsAndReturnAndException(Native Method)</span><br><span class="line">2019-04-18 13:31:04.590 7925-7987&#x2F;? I&#x2F;GoLog: Hello Mobile</span><br><span class="line">2019-04-18 13:31:04.590 7925-7987&#x2F;? I&#x2F;GoLog: Hello lecon</span><br></pre></td></tr></table></figure><p>这时候，你也许会发现，这几行代码的执行顺序是不确定的。因为 java 和 go 通信是跨进程调用，这几个方法有几个 log 是在 go 中输出，就不能保证执行顺序。</p><p>项目代码放到 github 上：<a href="https://github.com/leconio/AndroidCallGoDemo">https://github.com/leconio/AndroidCallGoDemo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;点击查看详情&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://leconio.github.io/categories/Go/"/>
    
    
  </entry>
  
  <entry>
    <title>解决使用gopath时候goget慢的问题</title>
    <link href="https://leconio.github.io/2021/03/04/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8gopath%E6%97%B6%E5%80%99goget%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://leconio.github.io/2021/03/04/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8gopath%E6%97%B6%E5%80%99goget%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-04T10:03:48.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>在开启 <code>GO111MODULE=on</code>的时候，我们设置 <code>GOPROXY</code> 可以大幅度解决 go get 慢的问题。<span id="more"></span> <strong>go mod 万岁</strong>。<br>但是对于一些老旧项目，必须使用 go path 这个方法就不灵了。</p><p>使用这个方法首先你要有一个代理，随便买个翻墙工具就行。配置好代理端口，例如 9080。</p><p>在 linux 或者 mac 平台使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY&#x3D;127.0.0.1:9080</span><br><span class="line">git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:9080</span><br><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:9080</span><br></pre></td></tr></table></figure><p>试试吧！<br>如果上面方法不灵的话怎么办，PS：<em>反正我是不灵的。</em><br>有一款软件是软件级代理软件，<code>Proxifier</code> 是一款收费软件，提供试用，对于一个 coder 来说，他是我最值得购买的一个软件了。</p><p>打开这个软件之后，配置代理，添加规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.golang.org;*.github.com;*.googlesource.com;*.gopkg.in</span><br></pre></td></tr></table></figure><p>如下图：<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/16148233886185.jpg"></p><p>重新 go get。虽然没有使用 go proxy 快，但是应应急是够了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开启 &lt;code&gt;GO111MODULE=on&lt;/code&gt;的时候，我们设置 &lt;code&gt;GOPROXY&lt;/code&gt; 可以大幅度解决 go get 慢的问题。</summary>
    
    
    
    <category term="Go" scheme="https://leconio.github.io/categories/Go/"/>
    
    
  </entry>
  
  <entry>
    <title>React Native 拆包总结</title>
    <link href="https://leconio.github.io/2021/03/04/React-Native-%E6%8B%86%E5%8C%85%E6%80%9D%E6%83%B3/"/>
    <id>https://leconio.github.io/2021/03/04/React-Native-%E6%8B%86%E5%8C%85%E6%80%9D%E6%83%B3/</id>
    <published>2021-03-04T09:57:47.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>在这里使用 Metro 的方式进行拆包，拆包的目的是可以按业务需要进行按需加载，同时可以热更新和热修复。<span id="more"></span></p><p>分包思路为：**基础包+业务包 1+业务包 2+…**。<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/untitled.png" alt="Untitled"></p><p>由上面可以看到，app 有原来的一个 bundle 分拆为多个，在 app 启动的时候，先加载公共部分 bundle，启动之后按需加载业务 bundle。每个 bundle 都对应一个容器，在 android 里面是 Activity，而在 iOS 里面是 ViewController。那么就可以理解为把之前单容器 bundle 的 app，拆分为多个容器加载。</p><h3 id="规划代码拆分"><a href="#规划代码拆分" class="headerlink" title="规划代码拆分"></a>规划代码拆分</h3><p>在进行 bundle 拆分之前，我们要制定好方案：</p><p>首先我们的代码一般分为：<strong>主要代码+依赖+工具+资源</strong></p><p>举个例子，如下图：<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/untitled-1.png" alt="Untitled 1"></p><p>红色框框里面的是<strong>工具代码</strong>，在打 bundle 的时候我们把他们排除，不打入 bundle 中。</p><p>白色框框里面的是<strong>依赖代码</strong>，我们选择性打入。</p><p>绿色框框里面的是<strong>主要代码</strong>，我们需要把他们打入到 bundle 中。</p><p><em>资源比较特殊，下面在进行讨论</em></p><p>在上面我们把 bundle 分为<strong>公共 bundle</strong>和<strong>业务 bundle</strong>，在分包的时候也是把代码分成上面三个部分，然后装配到不同的 bundle 中的。如下图所示：<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/untitled-2.png" alt="Untitled 2"><br>从上图可以看出，公共 bundle 与业务 bundle 唯一的区别就是多了依赖代码。这么分包的好处是：</p><ol><li>公共 bundle 可以做成没有 ui 页面的组件，然后异步加载。在进入业务页面的时候会非常快。</li><li>抽离业务模块的依赖部分，打出来的 bundle 会非常小，单独更新 bundle 时候，冗余量非常小。</li></ol><p>但是也有一些缺点，你是需要知道的：</p><ol><li>业务 bundle 也需要<code>node_module</code>依赖，在所有 bundle 中，如果 <code>package.json</code> 依赖版本不统一，有可能会引发白屏问题。</li></ol><blockquote><p>分包方案这部分要具体问题具体分析，解决痛点才是重要的。</p></blockquote><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>为了演示 demo，我们准备两个工程，一个主 bundle，一个业务 bundle。先来对比看一下这两个项目的目录结构。<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/04/untitled-3.png" alt="Untitled 3"><br>为了方便，我把原生工程（iOS 和 Android）放到公共 bundle 下面，在实际情况中，一般都会新增仓库，由不同的项目组分管。</p><p>在这里公共 bundle 仓库中，没有自有代码实现（没有 src 目录），因为 demo 的逻辑没有那么复杂，大家可以具体问题具体分析，放一些一些公共初始化的东西，如推送处理，后台服务等等。</p><p>注意：react native 在打包的过程中，如果一个依赖没有被使用到，即使你再 package.json 中声明了它，它也是不会被打包到 bundle 中的，所以为了把公共依赖都打到公共 bundle 中，我们需要在入口文件<code>index.js</code>中声明用到的依赖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;react-native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;react-native-gesture-handler&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;react-navigation&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;react-navigation-redux-helpers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;react-native-screens&quot;</span>;</span><br></pre></td></tr></table></figure><p>小提示：如果在运行过成功发生白屏现象，检查依赖代码（node_modules）是否被打入到公共 bundle 中，如果没有，就要主动声明它们。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>现在假设你已经指定了自己的分包方案，那么看一下 React Native 是如何生产 bundle 的，又是如何分包的。</p><p>React Native 打包命令为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node ./node_modules/react-native/local-cli/cli.js bundle</span><br><span class="line">--platform android</span><br><span class="line">--dev <span class="literal">false</span></span><br><span class="line">--entry-file index.js</span><br><span class="line">--bundle-output ./bundles/base.android.bundle</span><br><span class="line">--assets-dest ./bundles/res/android</span><br><span class="line">--config ./package.config.js</span><br><span class="line">--sourcemap-output  ./bundles/base.android.bundle.map</span><br><span class="line">--reset-cache</span><br></pre></td></tr></table></figure><p><code>--platform android</code> 指定运行平台，ios 平台则指定为 ios。</p><p><code>--dev false</code> 指定为 release 版本。</p><p><code>--entry-file</code> 指定入口文件，程序的主入口。</p><p><code>--bundle-output</code> <code>--assets-dest</code> <code>--sourcemap-output</code> 分别为 bundle 输出路径，资源输出路径，debug 用到的映射文件输出路径，以上三个路径必须存在。</p><p><code>--config</code> 在这里传入分包方案用到的 js 文件。</p><p>资源文件推荐直接输出到目的目录中，如果是 android 平台，输出到<code>src/main/res/</code>中</p><h3 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h3><p>由上面可以知道，分包的重点就是 <code>package.config.js</code> 这个文件了。在这里可以把源码 clone 下来，打开 base 工程下的这个文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  serializer: &#123;</span><br><span class="line">    createModuleIdFactory: createModuleIdFactory,</span><br><span class="line">    processModuleFilter: postProcessModulesFilter,</span><br><span class="line">    <span class="comment">/* serializer options */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，有两个很重要的方法<code>createModuleIdFactory</code> 和 <code>postProcessModulesFilter</code> 。<code>createModuleIdFactory</code> 是给每一个需要打包的文件去一个名字，避免多个 bundle 文件中代码冲突。而<code>postProcessModulesFilter</code> 就是用于标记哪些文件需要打入到 bundle 中的了。这个方法返回 false 表示不打入，true 表示打入。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base工程中 打包关键代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>[<span class="string">&quot;path&quot;</span>].indexOf(pathSep + <span class="string">&quot;node_modules&quot;</span> + pathSep) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>[<span class="string">&quot;path&quot;</span>].indexOf(<span class="string">&quot;index&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在公共依赖 base 工程，我们只打入路径中包含<strong>node_modules</strong>和<strong>入口文件</strong>。而在业务工程只打入<strong>主要代码</strong>和<strong>入口文件</strong>。如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务工程中 打包关键代码</span></span><br><span class="line"><span class="comment">// 提前过滤依赖</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>[<span class="string">&quot;path&quot;</span>].indexOf(pathSep + <span class="string">&quot;node_modules&quot;</span> + pathSep) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>[<span class="string">&quot;path&quot;</span>].indexOf(pathSep + <span class="string">&quot;src&quot;</span> + pathSep) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>[<span class="string">&quot;path&quot;</span>].indexOf(<span class="string">&quot;index&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，两个 bundle 和资源文件就生成了。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>这时候，分包的主要工作已经完成，把打包的产物放到远程工程里面已经可以正常运行。但是工作远远没有结束。首先这两个 bundle 没有任何版本信息，也无法判断时候被伪装。</p><p>我们的 bundle 应该做到热替换，如果只在服务器上拉取最新的 bundle，那么就无法保证分区域加载，或者灰度加载。所以我们还需要一个配置文件，用于记录这个 bundle 的日期、版本、灰度区域以及他的 md5 信息。</p><p>这个配置文件为 bundle 打完包之后就要生成，同时可以被中台（原生工程读取）。为了方便，我们使用 json 作为文件结构格式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;create_date&quot;</span>:<span class="number">1595317939331</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>:<span class="string">&quot;1.0.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;update_desc&quot;</span>:<span class="string">&quot;新加了一个弹框&quot;</span>,</span><br><span class="line">  <span class="string">&quot;md5&quot;</span>:<span class="string">&quot;0ca175b9c0f726a831d895e269332461&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 create_date 就代表这个 config 配置生成时间， version 是当前 bundle 版本号，md5 为打包 bundle 的唯一标识。这个配置文件可以使用脚本生成。</p><p>在 package.json 里面新增一个 postxxx ,其中 xxx 为你的打包命令。我使用的是 make，那么就新增 postmake，这样，在执行完成打包命令之后，他会自动执行。如下图</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;make&quot;</span>: <span class="string">&quot;node ./node_modules/react-native/local-cli/cli.js bundle --platform android --dev false --entry-file index.js --bundle-output ./bundles/base.android.bundle --assets-dest ./bundles/res/android --config ./package.config.js --sourcemap-output  ./bundles/base.android.bundle.map --reset-cache&quot;</span>,</span><br><span class="line">    <span class="string">&quot;makeiOS&quot;</span>: <span class="string">&quot;node ./node_modules/react-native/local-cli/cli.js bundle --platform ios --dev false --entry-file index.js --bundle-output ./bundles/base.ios.bundle --assets-dest ./bundles/res/ios --config ./package.config.js --sourcemap-output  ./bundles/base.ios.bundle.map --reset-cache&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postmake&quot;</span>:<span class="string">&quot;node aftermake.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么这里的<code>aftermake.js</code> ，主要工作就是生成配置文件了，并且把它打包成最终文件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> compressing = <span class="built_in">require</span>(<span class="string">&quot;compressing&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateMd5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejects</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stream = fs.createReadStream(<span class="string">&quot;bundles/base.android.bundle&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> fsHash = crypto.createHash(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stream.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">      fsHash.update(d);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    stream.on(<span class="string">&quot;end&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> md5 = fsHash.digest(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line">      resolve(md5);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readPackageInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejects</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;package.json&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        rejects(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> package = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">      resolve([package.version, package.update_desc]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">writeToFile</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">  fs.writeFile(<span class="string">&quot;bundles/config.json&quot;</span>, <span class="built_in">JSON</span>.stringify(info), <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> info = <span class="keyword">await</span> readPackageInfo();</span><br><span class="line">  <span class="keyword">let</span> md5 = <span class="keyword">await</span> generateMd5();</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    create_date: <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),</span><br><span class="line">    version: info[<span class="number">0</span>],</span><br><span class="line">    update_desc: info[<span class="number">1</span>],</span><br><span class="line">    md5: md5,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> writeToFile(config);</span><br><span class="line">  <span class="keyword">await</span> compressing.zip.compressDir(<span class="string">&quot;bundles&quot;</span>, <span class="string">&quot;base.zip&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>生成 <code>base.zip</code> 。这 zip 就可以放到应用分发平台，等待上线。</p><p>源码地址：<a href="https://github.com/leconio/ReactNativeInPlatform">https://github.com/leconio/ReactNativeInPlatform</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这里使用 Metro 的方式进行拆包，拆包的目的是可以按业务需要进行按需加载，同时可以热更新和热修复。</summary>
    
    
    
    <category term="ReactNative" scheme="https://leconio.github.io/categories/ReactNative/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 设备通过WIFI传输数据 - 点对点传输</title>
    <link href="https://leconio.github.io/2021/03/04/Android-%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87WIFI%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BC%A0%E8%BE%93/"/>
    <id>https://leconio.github.io/2021/03/04/Android-%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87WIFI%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BC%A0%E8%BE%93/</id>
    <published>2021-03-04T09:56:47.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>点对点传输（P2P）又是 WLAN 直连，他可以在没有中间接入点的情况下，通过 WLAN 进行直接互联。<span id="more"></span>他有用户介入操作少，比蓝牙传输速度高等特点，对设备的要求仅仅为 14，同时他又不占用 wlan0 网卡。</p><p>WLAN P2P 需要使用到 WifiP2pManager ，同时需要以下权限，这里面有一些是运行时权限，需要用户同意后才能使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;14&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CHANGE_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CHANGE_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>点对点传输（P2P）至少有两个有 Wifi 的设备，其中一个是 Android，首先确定 Android 设备和另外一个设备是否支持 P2P 连接。把手机连接电脑运行 <code>adb shell ip addr|grep p2p0 -A2</code>有输出就带边可以使用，一般来说都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span>: p2p0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="number">1500</span> qdisc mq state DOWN group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">00</span>:<span class="number">2d</span>:<span class="number">63</span>:a5:6b brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>注意看上面的输出，<code>link/ether 02:00:2d:63:a5:6</code> 为 p2p 的 Mac 地址，不同的设备之间使用 Mac 地址连接，所以首先要知道 P2P（p2p0）的 Mac 地址，这个和 wifi（wlan0）的地址不是同一个，在代码中需要使用下面方法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalMacAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;NetworkInterface&gt; interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());</span><br><span class="line">        <span class="keyword">for</span> (NetworkInterface ntwInterface : interfaces) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ntwInterface.getName().equalsIgnoreCase(<span class="string">&quot;p2p0&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] byteMac = ntwInterface.getHardwareAddress();</span><br><span class="line">                <span class="keyword">if</span> (byteMac == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteMac.length; i++) &#123;</span><br><span class="line">                    strBuilder.append(String.format(<span class="string">&quot;%02X:&quot;</span>, byteMac[i]));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (strBuilder.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    strBuilder.deleteCharAt(strBuilder.length() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> strBuilder.toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;Lecon&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下如何主动连接到 p2p 设备。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>首先通过 WifiP2pManager 的 initialize 初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val manager: WifiP2pManager? <span class="function">by <span class="title">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> </span>&#123;</span><br><span class="line">    getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>&#123;</span><br><span class="line">    mChannel = manager?.initialize(<span class="keyword">this</span>, mainLooper, <span class="keyword">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时使用广播来接受各种 P2P 连接的状态变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mChannel: WifiP2pManager.Channel? = <span class="keyword">null</span></span><br><span class="line"><span class="keyword">var</span> mReceiver: WiFiDirectBroadcastReceiver? = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> val mWifiP2pManager: <span class="function">WifiP2pManager by <span class="title">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> </span>&#123;</span><br><span class="line">    getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> val mIntentFilter: <span class="function">IntentFilter by <span class="title">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> </span>&#123;</span><br><span class="line">    IntentFilter().apply &#123;</span><br><span class="line">        addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)</span><br><span class="line">        addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)</span><br><span class="line">        addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)</span><br><span class="line">        addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    mChannel = mWifiP2pManager.initialize(<span class="keyword">this</span>, mainLooper, <span class="keyword">null</span>)</span><br><span class="line">    mReceiver = WiFiDirectBroadcastReceiver(mWifiP2pManager, mChannel, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WiFiDirectBroadcastReceiver</span>(</span></span><br><span class="line">        private val mManager: WifiP2pManager?,</span><br><span class="line">        <span class="keyword">private</span> val mChannel: WifiP2pManager.Channel?,</span><br><span class="line">        <span class="keyword">private</span> val mActivity: MainActivity</span><br><span class="line">) : BroadcastReceiver() &#123;</span><br><span class="line"><span class="function">override fun <span class="title">onReceive</span><span class="params">(context: Context, intent: Intent)</span> </span>&#123;</span><br><span class="line">    val action = intent.action</span><br><span class="line">    <span class="keyword">if</span> (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION == action) &#123;</span><br><span class="line"><span class="comment">// 当 WLAN P2P 在设备上启用或停用时广播</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION == action) &#123;</span><br><span class="line"><span class="comment">// 调用 requestPeers() 方法，以获得当前所发现对等设备的列表。</span></span><br><span class="line"><span class="comment">// 同时 在这里调用 connect 方法连接对方机器</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION == action) &#123;</span><br><span class="line"><span class="comment">// 当设备的 WLAN 连接状态更改时广播。</span></span><br><span class="line"><span class="comment">// 连接对方机器成功或者失败都会在这里回调</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION == action) &#123;</span><br><span class="line"><span class="comment">// 当设备的详细信息（例如设备名称）更改时广播</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边哪一些代码可以当成主动发起<strong>扫描之后的回调</strong>，使用广播进行回调说起来真的是挺复杂的，但是仔细想想，操作硬件设备本来就是跨进程的，而且这个还是长时间耗时操作，系统通过广播回调也是合理的。</p><p>到现在位置，可以把以上代码运行到 Android 上，他就可以最为 P2P 连接的被连接端。</p><h2 id="连接到设备"><a href="#连接到设备" class="headerlink" title="连接到设备"></a>连接到设备</h2><p>连接到设备的时候，首先要确定对方设备的 mac 地址，上面的两种方法是针对于 Android 设备的。一种是 adb 方式，一种是代码获取。</p><p>接下来要发现设备：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mWifiP2pManager.discoverPeers(mChannel, object : WifiP2pManager.ActionListener &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="meta">@MainActivity</span>, <span class="string">&quot;已发现设备，准备连接&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onFailure</span><span class="params">(reasonCode: Int)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返现设备之后，通过广播回调的 WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION 事件获取设备列表。找到列表中的设备与被连接设备 mac 地址一致的，确保我们被连接机器已经就绪。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mManager?.requestPeers(mChannel) &#123; peers -&gt;</span><br><span class="line">    <span class="keyword">for</span> (device in peers.deviceList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mac != <span class="keyword">null</span> &amp;&amp; mac.equals(device.deviceAddress, ignoreCase = <span class="keyword">true</span>)) &#123;</span><br><span class="line">            connectToDevice(device)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以连接设备了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val config = WifiP2pConfig()</span><br><span class="line">config.deviceAddress = <span class="string">&quot;被连接设备的Mac地址&quot;</span></span><br><span class="line">mManager?.connect(mChannel, config, object : WifiP2pManager.ActionListener &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mActivity, <span class="string">&quot;连接成功&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onFailure</span><span class="params">(reason: Int)</span> </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果被连接设备是 Android，你应该能看到一个连接提示，点击接受这样两台设备之间就连接成功了，通过 WIFI 两个设备可以实现近场通讯。</p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>通信之前需要知道被连接设备的 ip 地址。如果是 android 设备，在被连接设备执行<code>adb shell ip addr|grep p2p0 -A4</code> 就可以看到，这也是检测是否连接成功的方法。代码获取仍然要获取 p2p0 网卡的，wlan0 获取的 ip 地址不能用于这里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;NetworkInterface&gt; interfaces = Collections</span><br><span class="line">                .list(NetworkInterface.getNetworkInterfaces());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (NetworkInterface intf : interfaces) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!intf.getName().contains(<span class="string">&quot;p2p0&quot;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            List&lt;InetAddress&gt; addrs = Collections.list(intf</span><br><span class="line">                    .getInetAddresses());</span><br><span class="line">            <span class="keyword">for</span> (InetAddress addr : addrs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!addr.isLoopbackAddress()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> addr.getHostAddress().toUpperCase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被连接设备是一台服务器（在 Android 里面搭建一台服务器也是可以的），在这台设备上可以用 okhttp 等框架进行网络访问，或者使用 socket 进行传输。<br>现在两个手机（P2P）设备之间就可以同过 WLAN 直接通信了。</p><p>下面是源代码：<a href="https://github.com/leconio/WifiDircetP2PDemo">https://github.com/leconio/WifiDircetP2PDemo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;点对点传输（P2P）又是 WLAN 直连，他可以在没有中间接入点的情况下，通过 WLAN 进行直接互联。</summary>
    
    
    
    <category term="Android" scheme="https://leconio.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Kotlin 封闭类与枚举区别</title>
    <link href="https://leconio.github.io/2021/03/04/Kotlin-%E5%B0%81%E9%97%AD%E7%B1%BB%E4%B8%8E%E6%9E%9A%E4%B8%BE%E5%8C%BA%E5%88%AB/"/>
    <id>https://leconio.github.io/2021/03/04/Kotlin-%E5%B0%81%E9%97%AD%E7%B1%BB%E4%B8%8E%E6%9E%9A%E4%B8%BE%E5%8C%BA%E5%88%AB/</id>
    <published>2021-03-04T09:55:31.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>区别就是一个是静态的一个是动态的…</p><span id="more"></span><h1 id="Kotlin-封闭类与枚举区别"><a href="#Kotlin-封闭类与枚举区别" class="headerlink" title="Kotlin 封闭类与枚举区别"></a>Kotlin 封闭类与枚举区别</h1><p>在 Java 或者 Kotlin 中枚举可以携带属性，向下面这样。使用属性可以做一些差异性判断，比如静态工厂。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Car2</span></span>(<span class="keyword">val</span> maxSpeend:<span class="built_in">Int</span>) &#123;</span><br><span class="line">    AUDI(<span class="number">200</span>),BWM(<span class="number">210</span>),BENZ(<span class="number">220</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在实际开发中，有一些属性并不是直接就能确定的，甚至随着程序的运行才能确定，就用到了封闭类。举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Car3</span></span>(<span class="keyword">val</span> maxSpeed:<span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> AUDI:Car3(<span class="number">200</span>)</span><br><span class="line">    <span class="keyword">object</span> BWM:Car3(<span class="number">210</span>)</span><br><span class="line">    <span class="keyword">object</span> BENZ:Car3(<span class="number">220</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomCar1</span></span>(<span class="keyword">val</span> m:<span class="built_in">Int</span>) :Car3(DEFAULT_MAX_SPEED)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomCar2</span></span>(<span class="keyword">val</span> m:<span class="built_in">Int</span>) :Car3(DEFAULT_MAX_SPEED)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> DEFAULT_MAX_SPEED = <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">race</span><span class="params">(car:<span class="type">Car3</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(car) &#123;</span><br><span class="line">        Car3.AUDI -&gt; println (<span class="string">&quot;AUDI max_speed is &quot;</span> + Car3.AUDI.maxSpeed)</span><br><span class="line">        Car3.BWM -&gt; println(<span class="string">&quot;BWM max_speed is &quot;</span> + Car3.BWM.maxSpeed)</span><br><span class="line">        Car3.BENZ -&gt; println(<span class="string">&quot;BENZ max_speed is &quot;</span> + Car3.BENZ.maxSpeed)</span><br><span class="line">        <span class="keyword">is</span> Car3.CustomCar1 -&gt; println(<span class="string">&quot;CustomCar1 max_speed is &quot;</span> + (car.maxSpeed + car.m))</span><br><span class="line">        <span class="keyword">is</span> Car3.CustomCar2 -&gt; println(<span class="string">&quot;CustomCar2 max_speed is &quot;</span> + (car.maxSpeed + car.m))</span><br><span class="line">        <span class="keyword">else</span> -&gt; Car3.DEFAULT_MAX_SPEED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    race(Car3.AUDI)</span><br><span class="line">    race(Car3.BENZ)</span><br><span class="line">    race(Car3.CustomCar1(<span class="number">30</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，封闭类 Car3 中<code>AUDI BWM BENZ</code>的最大速度已经确定，直接写死在代码中。但是有一些数据是从数据库读取或者用户人为输入的，比如上面的 <code>CustomCar1</code>，他的最大速度可以使用构造器传入，在上面的<code>main</code>函数中。</p><p>在实际开发中，封闭类可以看做枚举类的一个拓展，这也是我用封闭类最多的地方。比如说放到回调接口中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="type">out R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> <span class="keyword">data</span>: T) : Result&lt;T&gt;()</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(<span class="keyword">val</span> exception: Exception) : Result&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;区别就是一个是静态的一个是动态的…&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://leconio.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>apk 拆包替换文件</title>
    <link href="https://leconio.github.io/2021/03/04/%E6%8B%86%E5%8C%85%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6/"/>
    <id>https://leconio.github.io/2021/03/04/%E6%8B%86%E5%8C%85%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6/</id>
    <published>2021-03-04T09:51:53.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 的开发测试过程中，为了替换 assets 文件或者更改 smail 文件，需要把 apk 拆开。<span id="more"></span>这个过程用到 apktool 和 jarsigner。其中 apktool 需要自己安装；jarsigner 是 jdk 自带的，也就是说需要 java 开发环境。</p><p>apktool 安装地址：<a href="https://ibotpeaches.github.io/Apktool/">https://ibotpeaches.github.io/Apktool/</a></p><p>如果你使用 mac 系统，可以使用 homebrew 安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install apktool</span><br></pre></td></tr></table></figure><p>其他系统参照官方方法：<a href="https://ibotpeaches.github.io/Apktool/install/">https://ibotpeaches.github.io/Apktool/install/</a></p><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拆包：</span><br><span class="line">apktool d [apk路径]</span><br><span class="line"></span><br><span class="line">封包：</span><br><span class="line">apktool b [拆包产生的文件夹]</span><br></pre></td></tr></table></figure><p>拆包使用<code>apktool d </code>指令，执行完成之后生成同名目录，封包使用<code>apktool b</code>指令，此时生成 apk 文件，但是这个 apk 是未签名的。不能对手机上已经安装的 apk 进行替换，下面进行签名。jarsigner 是 jdk 自带，不需要额外安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore [keystore路径] -storepass [密码] -signedjar [输出apk路径] [输入apk路径] [别名]</span><br></pre></td></tr></table></figure><blockquote><p>不同的 apk 签名可能不相同，使用 jarsigner —help 查看使用规则，现在的 jdk 都是兼容中文的，不用担心看不懂。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Android 的开发测试过程中，为了替换 assets 文件或者更改 smail 文件，需要把 apk 拆开。</summary>
    
    
    
    <category term="Android" scheme="https://leconio.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>使用frp访问公司内部网络</title>
    <link href="https://leconio.github.io/2021/03/03/%E4%BD%BF%E7%94%A8frp%E8%AE%BF%E9%97%AE%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C/"/>
    <id>https://leconio.github.io/2021/03/03/%E4%BD%BF%E7%94%A8frp%E8%AE%BF%E9%97%AE%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C/</id>
    <published>2021-03-03T21:20:56.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>观看之前，建议你有 ssh 和简单的 shell 使用经验。</p></blockquote><span id="more"></span><p>顾名思义，这是一个通过内网穿透自建 vpn 来访问公司内网的教程。说到内网穿透、vpn 都不是什么新鲜的概念，但是这些工具组合起来确实有很多好玩的地方。在这里，就是他们其中的一种组合游戏。<br>好戏开始之前，我们先提出几个疑问，让我猜猜你想的对不对。</p><pre><code>1. 我在家里可以访问公司内网吗，比如打卡，收发邮件之类的？2. 我需要哪些必备的东西呢？3. frp是个什么工具？</code></pre><p>那么，带着疑问我们开始吧！</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><p>一句话来说就是，通过 frp 把公司计算机的 ssh 暴露出来，个人计算机使用公司计算机 ssh 的 socks5 代理进行上网。</p><p>首先介绍一下 frp 这个软件，经常做微信开发的小伙伴应该有接触到，它是搞内网穿透的。在调试公众号或者小程序接口的时候，需要把开发服务器映射到公网上，这样微信服务器才能成功回调到开发者计算机。但是，我们开发计算机在局域网呀，在使用 NAT 转换之后，公网服务器无法直接访问局域网计算机；也就是说，我可以访问互联网，但是互联网无法主动访问我。frp 就是解决这个问题的，它把我自己的计算机的 web 服务放到公网上，然后我们就可以从互联网访问到它。</p><p>那么话说回来了，这和今天这个话题有什么联系呢？我们要让个人计算机使用公司的计算机网络进行网络访问，就必须把公司的计算机暴露在互联网当中。如下图：<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15485604883245.jpg"></p><p><strong><em>其实你已经注意到了：把公司计算机直接暴露在公网，会不会不安全呀？当然会，实际使用过程中，一定要按需开启，并且使用安全验证。</em></strong></p><p>frp 不仅仅能把 web 服务暴露在公网，而且还可以把 ssh 服务暴露在公网上。也就是说，我可以通过个人计算机直接 ssh 公司的内网的计算机。</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>代理我们使用的是 ssh 的 socks5 代理，ssh 有这样一个功能，就是把 ssh 服务器当成一个 socks5 正向的代理，把监听到 socks5 服务端口的流量转发到 ssh 服务器上。就可以实现个人计算机通过公司内网计算机进行上网了。</p><p><em>下面介绍需要用到的设备以及环境。</em></p><h1 id="原材料"><a href="#原材料" class="headerlink" title="原材料"></a>原材料</h1><p>上面说到，要想实现必须有三台计算机。首先，<strong>公司的个人电脑</strong>和<strong>家中的电脑</strong>是其中两个，还需要一个<strong>公网电脑</strong>进行数据中转。</p><h3 id="流量转发端"><a href="#流量转发端" class="headerlink" title="流量转发端"></a>流量转发端</h3><p>流量转发端是公网中转计算机，它是什么呢？简言之就是有独立 ip 的服务器，这个很容易就买到了，比如阿里云或者腾讯云什么的，很多小伙伴在双 11 和和双 12，被他们冲了一波业绩吧！现在用起来吧，我这里环境使用 Centos7，使用 Ubuntu 的小伙伴也关系，只是防火墙设置不同而已。</p><h3 id="流量提供端"><a href="#流量提供端" class="headerlink" title="流量提供端"></a>流量提供端</h3><p>流量提供端为公司的计算机，必须支持 ssh 服务，Linux 和 Mac 原生支持了，Windows 需要额外下载软件进行支持，比如 Windows10 的内置 Ubuntu，我这里使用 Mac 系统。</p><h3 id="流量消费端"><a href="#流量消费端" class="headerlink" title="流量消费端"></a>流量消费端</h3><p>流量消费端为个人计算机，可以是 Mac、Linux，或者 Windows，Android，后两个需要额外软件，iOS 没有试过。我这里使用 Mac 系统。</p><blockquote><p>我个人不建议使用 Windows 最为搭建这套环境，Windows 下的 Linux 子环境实在是难以折腾，即使通过虚拟机或者 bash 等折腾成功，还要考虑网络问题。</p></blockquote><h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><p>搭建过程分为以下几步。</p><pre><code>1. 在中转服务器和公司计算机之间搭建frp服务。2. 个人计算机可以通过ssh访问公司计算机。3. 把个人计算机的ssh流量作为局部代理4. 设置局部代理</code></pre><p>这样一来工作就清晰了起来！</p><h3 id="1-搭建-frp-服务"><a href="#1-搭建-frp-服务" class="headerlink" title="1. 搭建 frp 服务"></a>1. 搭建 frp 服务</h3><p>frp 分为客户端和服务端两个软件，我们可以从 <a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a> 获得（他们在同一个压缩内）。<strong>其中 frps 是服务器端，frpc 是客户端。把 frps 放到中转服务器，把 frpc 放到公司计算机。</strong></p><p>同时，不管设计 frps 还是 frpc，都仅仅需要一个软件和一个配置文件即可运行。</p><h4 id="搭建中转服务器的-frps-服务（操作中转服务器）"><a href="#搭建中转服务器的-frps-服务（操作中转服务器）" class="headerlink" title="搭建中转服务器的 frps 服务（操作中转服务器）"></a>搭建中转服务器的 frps 服务（操作中转服务器）</h4><p>这一步的目的是建立 frp 服务器。首先 ssh 到中转服务器，下载 frp 软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.23.2&#x2F;frp_0.23.2_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.23.2_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>得到解压的文件，我们只需关注 frps 和 frps.ini 这两个，其他的可以删除。<br>编辑 frps.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br></pre></td></tr></table></figure><p>然后运行 frp 服务端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure><p>当然，为了方便使用，也可以后台运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;frpc -c .&#x2F;frpc.ini &amp;</span><br></pre></td></tr></table></figure><h4 id="搭建公司计算机的-frpc-服务（操作公司计算机）"><a href="#搭建公司计算机的-frpc-服务（操作公司计算机）" class="headerlink" title="搭建公司计算机的 frpc 服务（操作公司计算机）"></a>搭建公司计算机的 frpc 服务（操作公司计算机）</h4><p>这一步要打通<strong>公司计算机</strong>和<strong>中转服务器</strong>之间的连接。在这之前，首先要确定公司的计算机时候开启 ssh 服务器。Linux 默认都会开启，Windows 用户只能去找软件来使用，其中 Bitvise SSH Server 还不错，使用起来也比较简单，只是收费。Mac 系统参考如下：</p><p><strong>系统偏好设置 -&gt; 共享 -&gt; 远程登录</strong>。勾选上，然后在右边添加自己用户。<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486505796374.jpg" alt="-w340"><br>设置好 ssh 服务之后，请下载 frp 客户端软件。这里需要 frpc 和 frpc.ini 这两个文件，其他都可以删除掉。</p><blockquote><p>下载时候要选择好对应平台再下载。客户端和服务端如果系统平台不一样，就不能用同一份（虽然客户端和服务端在同一个文件夹中）。</p></blockquote><p>然后编辑 fric.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; x.x.x.x</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000</span><br></pre></td></tr></table></figure><p>注意，这里虽说是在设置公司计算机的客户端配置，但是涉及的到两个端口<code>7000</code>和<code>6000</code>，在中转服务器中也需要<strong>添加防火墙例外规则</strong>，腾讯云或则阿里云好像还要添加安全组。</p><p>其中，<code>x.x.x.x</code>为你中转服务器的公网 ip。<code>server_port</code>是中转服务器和公司服务器通信的端口，<code>remote_port</code>是 ssh 的虚拟端口，我们连接时候指定的端口就是它。其他的参数都无关紧要，具体可以了解 <a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a> 。</p><p>现在启动公司计算机的 frp 客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure><p>到这里，主要工作基本上已经完成了，现在就来测试一下是否可以从个人计算机通过 ssh 连接到公司的计算机吧。</p><h3 id="2-SSH-到公司计算机（操作个人计算机）"><a href="#2-SSH-到公司计算机（操作个人计算机）" class="headerlink" title="2. SSH 到公司计算机（操作个人计算机）"></a>2. SSH 到公司计算机（操作个人计算机）</h3><p>如果使用的是 mac 或者 linux 可以直接使用下面的命令，连接到公司计算机。如果是 windows，需要下载 putty 或者 linux 子系统等 ssh 软件（后文提到）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort&#x3D;6000 [用户名]@x.x.x.x</span><br></pre></td></tr></table></figure><p>其中，x.x.x.x 是你中转服务器的公网 ip。注意这里一定要加上面指定的端口，不然会连接到中转服务器的 ssh 服务。不出什么问题，就可以连接到公司计算机了。</p><blockquote><p>在这个过程中，如果很久都没连接上，或者被远程主动关闭，请检查防火墙的设置。我们可以使用 telnet 命令测试远程端口是否开启。</p></blockquote><p>教程到这里，好像和 vpn 好像还没有什么太大的关系，仅仅是可以控制公司的计算机而已。不要忘记，ssh 有一个很好的功能，就是把远程服务器的流量，变成本地计算机的 socks5 代理。</p><h3 id="3-设置-ssh-的-socks5-代理（操作个人计算机）"><a href="#3-设置-ssh-的-socks5-代理（操作个人计算机）" class="headerlink" title="3. 设置 ssh 的 socks5 代理（操作个人计算机）"></a>3. 设置 ssh 的 socks5 代理（操作个人计算机）</h3><p>好的，现在可以按 control+c 停止连接。然后，Linux 用户和 Mac 用户可以直接输入以下命令直接开启 sock5 隧道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 [公司计算机账户]@[中转服务里ip]</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 spawn@192.168.2.1</span><br></pre></td></tr></table></figure><p>注意以上命令，这里又多出一个 1080 的端口，这个端口是为本地开的。任何把代理端口指向这个位置的连接，都可以使用这个代理，所以这里要记住这个端口。</p><p>如果你想让局域网其他电脑也可以访问，那么把 127.0.0.1 换成 0.0.0.0。</p><blockquote><p>注意：ssh 的 sock5 代理如果长时间不使用会自动断开连接，当然，使用<code>autossh</code>可以解决这个问题。</p></blockquote><p>Windows 用户需要额外的软件，推荐使用 putty。操作步骤如下：打开 putty<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486510122980.jpg" alt="-w334"><br>其中 x.x.x.x 为中转服务 ip，端口填写 6000</p><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486510241269.jpg" alt="-w343"><br>按照上图操作步骤操作<br>然后检查路由表，看看是否正常开启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -a</span><br></pre></td></tr></table></figure><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486510398204.jpg" alt="-w733"></p><p>到此 Windows 可以开启一个端口为 1080 的 sock5 隧道<br>开启 sock5 隧道之后，怎么能检测一下呢？打开一个新的 Shell，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">curl cip.cc</span><br></pre></td></tr></table></figure><p>注意，上面的 1080 就是之前预留的端口，地址 127.0.0.1 指向本地。接下来使用上面命令看一看公网 ip 是不是和公司计算机的一样。（PS. 公司计算机也可以输入这个命令查看，或者直接百度关键字 ip。如果相同，那么以上过程就全部成功了！</p><blockquote><p>插个题外话，如果把公司计算机去掉，直接连接中转服务器的 ssh 服务的话，你懂得~。ssh 比 pptp 和 l2tp 要爽哦，关键日子那几天，纸飞机隧道都不可用，全靠它呢！！！</p></blockquote><p>接下来，有了 sock5 代理，按理说文章应该可以结束了。但是毕竟还没有看到效果，那么接下来简单说说它的几种食用方式，这个过程可以任意发挥，没有固定方式！</p><h3 id="通过局部代理上网"><a href="#通过局部代理上网" class="headerlink" title="通过局部代理上网"></a>通过局部代理上网</h3><p>上面我们说到，如何把 ssh 流量变成 socks5 局部代理，那么现在就是怎么使用这个局部代理了。</p><h4 id="命令行代理"><a href="#命令行代理" class="headerlink" title="命令行代理"></a>命令行代理</h4><p>这种代理方式只在当前 session 生效，一旦关闭当前命令行，就会失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启方式 export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">关闭方式 export ALL_PROXY&#x3D;</span><br><span class="line">检验方式 curl cip.cc</span><br></pre></td></tr></table></figure><h4 id="Mac-全局代理"><a href="#Mac-全局代理" class="headerlink" title="Mac 全局代理"></a>Mac 全局代理</h4><p><strong>系统偏好设置 -&gt; 网络 -&gt; 高级 -&gt; 代理 -&gt; socks 代理</strong> 勾选这个<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486512763854.jpg" alt="-w433"><br>点击确定。</p><h4 id="Chrome-插件分网址代理"><a href="#Chrome-插件分网址代理" class="headerlink" title="Chrome 插件分网址代理"></a>Chrome 插件分网址代理</h4><p>推荐使用插件 SwitchyOmega，由于本教程不是讲局部代理使用方式，直接贴这个插件的使用教程 <a href="https://github.com/FelisCatus/SwitchyOmega">https://github.com/FelisCatus/SwitchyOmega</a> 。<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486514601716.jpg" alt="-w473"><br>使用<code>SwitchyOmega</code>可以针对不同网页使用不同的代理方式，比如说，1080 端口是访问公司内网的，1088 端口是土啬的。它还可以破除公司对于某些网站的限制，同时也代理就不用切来切去了，十分方便。</p><h4 id="Proxifier-分应用代理"><a href="#Proxifier-分应用代理" class="headerlink" title="Proxifier 分应用代理"></a>Proxifier 分应用代理</h4><p>使用 SwitchyOmega 可以在访问不同网站的时候使用不同的代理设置，那么 Proxifier 就可以针对于不同的应用使用不同的代理，甚至切断互联网连接。或者我们可以把上面教程反过来玩，然公司服务器当个人计算机，家中的电脑扮演公司计算机的角色。使某些 App 走家中的流量，就可以简单破除公司对于某些 App 的网路限制，比如微信或者音乐视频类软件，但是要注意 dns 的设置。</p><p>它是一个十分优秀的软件，但是需要付费。如果是针对外企用户需要频繁切换网络的用户来说，它的确是一个福音。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>一般来说，公司的网络安全部都不会允许把公司计算机暴露在公网之下，本文只讨论技术，大家好好玩儿~</p><h1 id="2021-年-3-月-2-日更新"><a href="#2021-年-3-月-2-日更新" class="headerlink" title="2021 年 3 月 2 日更新"></a>2021 年 3 月 2 日更新</h1><p>使用<code>nps</code>后者<code>goproxy</code>过程会更简单 - -</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;观看之前，建议你有 ssh 和简单的 shell 使用经验。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="玩儿" scheme="https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Android的Binder的调用方面</title>
    <link href="https://leconio.github.io/2021/03/03/Android%E7%9A%84Binder%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2/"/>
    <id>https://leconio.github.io/2021/03/03/Android%E7%9A%84Binder%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2/</id>
    <published>2021-03-03T21:07:07.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>从 Binder 的远程方法调用来看，Proxy 是调用端，Stub 是被调用端。<span id="more"></span> 由 AIDL 的 Interface 实现类，可以看出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.util.List&lt;com.leconio.aidlsender.Person&gt; getPersons() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    java.util.List&lt;com.leconio.aidlsender.Person&gt; _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getPersons, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefaultImpl().getPersons();</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.createTypedArrayList(com.leconio.aidlsender.Person.CREATOR);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取两个 Parcel，一个用于传递数据，一个用于接收数据。每个 Parcel 中都有一个<code>mNativePtr</code>，是个 long 类型，其实他是 JNI 中的 Parcel，由 reinterpret_cast 转换而来。也就是说，Java 层的 Parcel 包裹着 JNI 层的 Parcel。Parcel 是在一个 Parcel 池中获取，这个池大小是 6。<br><code>mNativePtr</code> 会在 CPP 代码中 Parcel 初始化的时候被初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ParcelRef&gt; parcelRef = ParcelRef::create();</span><br><span class="line">    parcelRef-&gt;incStrong(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(android_os_Parcel_create));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(<span class="keyword">static_cast</span>&lt;Parcel *&gt;(parcelRef.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>mRemote</code>的实现类是 Java 层的<code>ProxyBinder</code>，这个地方就调用到了 ProxyBinder 中的<code>transact</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AppOpsManager.resumeNotedAppOpsCollection(prevCollection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transactListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            transactListener.onTransactEnded(session);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tracingEnabled) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到了 cpp 层的<code>transactNative</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_os_BinderProxy</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jboolean replyObjOwnsNativeParcel,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); <span class="comment">// 获取BPBinder</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags); <span class="comment">// 由BPBinder再次传递</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">    mHandle, code, data, reply, flags); <span class="comment">// 由IPCThreadState传递给驱动</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有 reply 的话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply); <span class="comment">// 等待回复</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// 无限循环等待结果</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Processing waitForResponse Command: &quot;</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> BR_REPLY: <span class="comment">// 如果返回消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer); <span class="comment">// 设置返回值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>reply</code> 是 Parcel。我们看看<code>Parcel::ipcSetDataReference</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parcel::ipcSetDataReference</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freeData();</span><br><span class="line"></span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data); <span class="comment">// 设置值</span></span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects);</span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;%s: bad object offset %&quot;</span> PRIu64 <span class="string">&quot; &lt; %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> flat_binder_object* flat</span><br><span class="line">            = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> flat_binder_object*&gt;(mData + offset);</span><br><span class="line">        <span class="keyword">uint32_t</span> type = flat-&gt;hdr.type;</span><br><span class="line">        <span class="keyword">if</span> (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE ||</span><br><span class="line">              type == BINDER_TYPE_FD)) &#123;</span><br><span class="line">            <span class="comment">// We should never receive other types (eg BINDER_TYPE_FDA) as long as we don&#x27;t support</span></span><br><span class="line">            <span class="comment">// them in libbinder. If we do receive them, it probably means a kernel bug; try to</span></span><br><span class="line">            <span class="comment">// recover gracefully by clearing out the objects, and releasing the objects we do</span></span><br><span class="line">            <span class="comment">// know about.</span></span><br><span class="line">            android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">&quot;135930648&quot;</span>);</span><br><span class="line">            ALOGE(<span class="string">&quot;%s: unsupported type object (%&quot;</span> PRIu32 <span class="string">&quot;) at offset %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                  __func__, type, (<span class="keyword">uint64_t</span>)offset);</span><br><span class="line">            releaseObjects();</span><br><span class="line">            mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中，设置了返回值 mData。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 Binder 的远程方法调用来看，Proxy 是调用端，Stub 是被调用端。</summary>
    
    
    
    <category term="黑洞" scheme="https://leconio.github.io/categories/%E9%BB%91%E6%B4%9E/"/>
    
    
  </entry>
  
  <entry>
    <title>Dart对比java快速入门</title>
    <link href="https://leconio.github.io/2020/03/03/Dart%E5%AF%B9%E6%AF%94java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://leconio.github.io/2020/03/03/Dart%E5%AF%B9%E6%AF%94java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-03T21:38:18.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>首先本文是通过对比其他语言（主要是 java）快速入门</p><span id="more"></span><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>首先本文是通过对比其他语言（主要是 java）快速入门，建议您至少要熟悉一门静态语言或者动态语言。Dart 和 java 以及 C#都差不多，基本上不用学习可以直接使用，从这里可以你可以了解 Dart 有些特别之处。</p><p>首先从一段代码入门吧：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    printTest(<span class="string">&#x27;hello <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> printTest(<span class="built_in">String</span> variableInteger) &#123;</span><br><span class="line">  <span class="built_in">print</span>(variableInteger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，Dart 语言主入口是<code>main函数</code>，他可以不用属于某个类。一眼看上去和 java 差不多。流程控制也是由小括号和大括号构成，不用考虑缩进。<strong>结尾必须要加上分号</strong>。</p><h3 id="声明数据类型"><a href="#声明数据类型" class="headerlink" title="声明数据类型"></a>声明数据类型</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">int</span> l = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">String</span> str1 = <span class="string">&quot;str1&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dynamic</span> d = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> j = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> k = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 是强类型语言，变量都会有一个类型。你可以向 java 那样直接声明类型，同样可以像 swift 或者 Kotlin 那样使用类型推导。Dart 的类型推导使用 final,var,const,dynamic 关键字。</p><ul><li><code>var</code>修饰变量，这个没什么好说的。</li><li><code>final</code>表示不可变的，修饰内置数据类型，值不可变；修饰对象表示引用不可变，使用到的频率很高。</li><li><code>const</code>是编译时常量，他表示始终不可变，无论修饰内置类型还是对象，或者是数据结构。</li><li><code>dynamic</code>是任意类型，有点像 java 里面的<code>Object</code>，Kotlin 中的<code>Any</code>。</li></ul><blockquote><p>使用 const 修饰的都是编译时常量。它区别于运行时，它的值是不可变的。<br><strong>所有的数据类型，不管是 int 还是 String，初始值都是<code>null</code></strong></p></blockquote><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="numbers、strings-和-booleans"><a href="#numbers、strings-和-booleans" class="headerlink" title="numbers、strings 和 booleans"></a>numbers、strings 和 booleans</h4><p>首先是<code>numbers</code>,<code>strings</code>,<code>booleans</code>其中 numbers 包括<code>int</code>和<code>double</code>类型，分别表示整数和浮点数。strings 就是<code>String</code>类型，普通的字符串。booleans 类型是<code>bool</code>只包含<code>true</code>和<code>false</code>。</p><pre><code>numbers* int* doublestrings* Stringbooleans* bool</code></pre><p>如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// numbers</span></span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">double</span> d = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串转数字</span></span><br><span class="line">  <span class="comment">// 这里就使用了类型推导</span></span><br><span class="line">  <span class="keyword">final</span> p1 = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> p2 = <span class="string">&quot;3.3&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">int</span>.parse(p1));</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">double</span>.parse(p2));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// string</span></span><br><span class="line">  <span class="comment">// 可以使用（&#x27;xxx&#x27;）（&quot;xxx&quot;）（&#x27;&#x27;&#x27;xxx&#x27;&#x27;&#x27;） 三种方式初始化字符串，和Kotlin很像。</span></span><br><span class="line">  <span class="comment">// 字符串比较的是值</span></span><br><span class="line">  <span class="keyword">final</span> str1 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> str2 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str1 == str2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> str3 = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> str4 = <span class="string">&#x27;&#x27;&#x27;test&#x27;&#x27;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str4);</span><br><span class="line">  <span class="built_in">print</span>(str4 == str3); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m <span class="subst">$&#123;str4&#125;</span>!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//booleans</span></span><br><span class="line">  <span class="comment">// null 可以直接用来判断，它是false</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;null is true&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;null is false&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.isEmpty);</span><br><span class="line"><span class="comment">//   final list = [];</span></span><br><span class="line"><span class="comment">//   if(!list) &#123;</span></span><br><span class="line"><span class="comment">//     print(&#x27;not empty&#x27;);</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 的数据结构包括 list 和 map</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>list</code>对应的就是 java 里面的 List，list 可以像 Python 等语言那样使用<code>[]</code>进行数组操作，参照以下示例代码。<br>List 有几个在 flutter 非常常用的初始化方式，分别为<code>filled</code>和<code>generate</code>。具体参考：<a href="https://api.dartlang.org/stable/2.1.0/dart-core/List-class.html">https://api.dartlang.org/stable/2.1.0/dart-core/List-class.html</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">final</span> list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">  <span class="comment">// 编译时常量</span></span><br><span class="line">  <span class="keyword">final</span> list2 = <span class="keyword">const</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="comment">//   list2[2] = 8; error</span></span><br><span class="line">  <span class="built_in">print</span>(list2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化2</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list3 = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">print</span>(list3); <span class="comment">// [null, null, null, null, null]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化3 filled 第一个参数是个数，第二个是添加的值</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list4 = <span class="built_in">List</span>.filled(<span class="number">3</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">print</span>(list4); <span class="comment">// [10,10,10]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化4 类似Python的Map生成</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list5 = <span class="built_in">List</span>.generate(<span class="number">3</span>,(i) =&gt; i * <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(list5); <span class="comment">// [0, 3, 6]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改 使用list1</span></span><br><span class="line">  list1[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">print</span>(list1); <span class="comment">// [1, 2, 8, 4, 5]</span></span><br><span class="line">  <span class="comment">// 添加</span></span><br><span class="line">  list1.add(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//   list1[10] = 20; Index out of range</span></span><br><span class="line">  <span class="built_in">print</span>(list1); <span class="comment">// [1, 2, 8, 4, 5, 10]</span></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  list1.remove(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">print</span>(list1); <span class="comment">// [1, 2, 8, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code> 对应 java 里面的 Map，他的操作方式有点像 Python。需要注意的有几点。</p><ul><li>Map 的 Key 不能有重复的</li><li>如果使用 int 类型作为 key，取值的时候优先使用 key 匹配，然后是下标。</li><li>取不到值不会抛异常，直接返回 null</li><li>Map 和 List 可以转换为 Json,来回转换时深拷贝。</li></ul><p>其他 API 参考：<a href="https://api.dartlang.org/stable/2.1.0/dart-core/Map-class.html">https://api.dartlang.org/stable/2.1.0/dart-core/Map-class.html</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:convert&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"><span class="keyword">final</span> map1 = &#123;</span><br><span class="line">    <span class="string">&quot;test1key&quot;</span> : <span class="string">&quot;test1value&quot;</span>,</span><br><span class="line"><span class="comment">//     &quot;test1key&quot; : &quot;test1value&quot;, Key 不能相同</span></span><br><span class="line">    <span class="number">123</span> : <span class="string">&quot;123value&quot;</span>,</span><br><span class="line">    <span class="keyword">null</span> : <span class="string">&#x27;NULL&#x27;</span>,</span><br><span class="line">    <span class="number">2</span> : <span class="string">&#x27;2&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">print</span>(map1); <span class="comment">// &#123;test1key: test1value, 123: 123value, null: NULL, 2: 2&#125;</span></span><br><span class="line">  <span class="comment">// 获取值</span></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="number">123</span>]); <span class="comment">// key取值 123value</span></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="number">1</span>]); <span class="comment">// 下标取值 null</span></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="number">2</span>]); <span class="comment">// 同时存在时候，优先Key取值；结果为 2</span></span><br><span class="line">  <span class="comment">// 追加值</span></span><br><span class="line">  map1[<span class="string">&#x27;appendKey&#x27;</span>]  = <span class="string">&#x27;appendVal&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(map1);</span><br><span class="line">  <span class="comment">// 更改值</span></span><br><span class="line">  map1[<span class="string">&#x27;appendKey&#x27;</span>]  = <span class="string">&#x27;appendVal123&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(map1);</span><br><span class="line"> map1[<span class="string">&#x27;appendKey&#x27;</span>] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="built_in">print</span>(map1); <span class="comment">// 置为null之后，key不会消失</span></span><br><span class="line">  map1.remove(<span class="string">&#x27;appendKey&#x27;</span>);</span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="built_in">print</span>(map1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="string">&#x27;non-key&#x27;</span>]); <span class="comment">// 不会报错 打印 null</span></span><br><span class="line">  <span class="built_in">print</span>(map1.length); <span class="comment">// 长度 4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// json 转换</span></span><br><span class="line">  <span class="comment">// 使用const修饰的数据结构，不可改变。</span></span><br><span class="line">  <span class="keyword">final</span> map2 = <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;lecon&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;ss&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">final</span> jsonText = jsonEncode(map2);</span><br><span class="line">  <span class="built_in">print</span>(jsonText); <span class="comment">// &#123;&quot;name&quot;:&quot;lecon&quot;,&quot;age&quot;:23,&quot;ss&quot;:[1,2,3,4,4]&#125;</span></span><br><span class="line">  <span class="keyword">final</span> mapObj = jsonDecode(jsonText);</span><br><span class="line">  <span class="built_in">print</span>(mapObj); <span class="comment">// &#123;name: lecon, age: 23, ss: [1, 2, 3, 4, 4]&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h4><p>这东西其实就是字符集的扩编，可以用它显示一些表情符号</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(clapping);</span><br><span class="line">  <span class="built_in">print</span>(clapping.codeUnits);</span><br><span class="line">  <span class="built_in">print</span>(clapping.runes.toList());</span><br><span class="line"></span><br><span class="line">  Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">      <span class="string">&#x27;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Dart 的函数比 java 多了几个概念。比如在参数列表里面添加个大括号，是<code>可选命名参数</code>；加个中括号叫<code>可选位置参数</code>。</p><ul><li>可选命名参数类似 Python 里面的**kwargs，参考下面示例代码<code>func3</code>；</li><li>可选位置参数类似 Python 里面的*args，参考下面<code>func5</code>。</li><li>可选命名参数和可选位置参数可以有默认值，普通参数不能有，参考<code>func6</code>。</li><li>函数之间可以互相嵌套，互相调用，但他们都有自己作用域。</li><li>若果函数简单可以使用<code>()=&gt; value</code>简写。</li></ul><p>比如</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> test() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写成</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> test ()=&gt; <span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure><p>下面是示例代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#x27;package:meta/meta.dart&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"> func1(<span class="number">123</span>);</span><br><span class="line"> func2(<span class="string">&#x27;222&#x27;</span>);</span><br><span class="line">  func3(<span class="string">&quot;lecon&quot;</span>);</span><br><span class="line"><span class="comment">//   func3(&quot;lecon&quot;,&quot;spawn&quot;,123); error,使用下边的中括号，注意区别。这个使用key区分，下面使用位置区分</span></span><br><span class="line">  func3(<span class="string">&quot;lecon&quot;</span>,param2:<span class="string">&quot;spawn&quot;</span>,param3:<span class="number">123</span>);</span><br><span class="line"><span class="comment">//   func4(&quot;lecon&quot;,param2:&quot;spawn&quot;); error required</span></span><br><span class="line">  func5(<span class="string">&quot;lecon&quot;</span>,<span class="string">&quot;spawn&quot;</span>,<span class="string">&quot;hahaa&quot;</span>);</span><br><span class="line">  func6(<span class="string">&quot;lecon&quot;</span>,age:<span class="number">25</span>);</span><br><span class="line">  <span class="built_in">print</span>(func7());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func1(param1) &#123;</span><br><span class="line">  <span class="built_in">print</span>(param1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> func2(<span class="built_in">String</span> param2) &#123;</span><br><span class="line">  <span class="built_in">print</span>(param2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func3(<span class="built_in">String</span> param1,&#123;<span class="built_in">String</span> param2,<span class="built_in">int</span> param3&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I am <span class="subst">$&#123;param1&#125;</span>, Hi <span class="subst">$&#123;param2&#125;</span>,I am <span class="subst">$&#123;param3&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test in flutter</span></span><br><span class="line"><span class="comment">// void func4(String param1,&#123;String param2,@required int param3&#125;) &#123;</span></span><br><span class="line"><span class="comment">//   print(&quot;I am $&#123;param1&#125;, Hi $&#123;param2&#125;,I am $&#123;param3&#125;&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func5(<span class="built_in">String</span> param1,[<span class="built_in">String</span> param2,<span class="built_in">String</span> param3]) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I am <span class="subst">$&#123;param1&#125;</span>, bian bu <span class="subst">$&#123;param2&#125;</span> xia qu le <span class="subst">$&#123;param3&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有使用&#123;&#125;和[]的才可以有默认值</span></span><br><span class="line"><span class="keyword">void</span> func6(<span class="built_in">String</span> param1,&#123;<span class="built_in">int</span> age = <span class="number">23</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I am <span class="subst">$&#123;param1&#125;</span>, I am <span class="subst">$&#123;age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func7() &#123;</span><br><span class="line">  <span class="keyword">void</span> func8() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> func9() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  retrun () =&gt; <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Dart 的流程控制和 java 的用法基本一样,这里就不介绍了。</p><p>有个 for in 要说下，和 JavaScript 很像。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;&#125;</span><br></pre></td></tr></table></figure><p>相当于 java 的高级 for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : indexs) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>相对于 java 有这几点需要注意</p><ul><li><code>new</code>关键字可以省略</li><li>一个类同名构造器只能有一个，也就是说可以给构造器起其他名字。所以可以把构造器分为<code>默认构造器</code>和<code>命名构造器</code>。</li><li>命名构造器不能自动继承，参考下面</li><li>Dart 使用<code>this</code>代表当前对象</li><li>初始化列表</li><li>Dart 有继承和接口概念，和 java 基本差不多，同时多了个<code>混入</code>的的概念<code>minix</code>，这个非常好理解。</li></ul><p>下面这个例子是类构造器的基本使用</p><h4 id="普通构造器和继承"><a href="#普通构造器和继承" class="headerlink" title="普通构造器和继承"></a>普通构造器和继承</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line">  <span class="built_in">String</span> dantengt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，冒号后边是初始化列表，用，隔开。</span></span><br><span class="line">  Person() :dantengt = <span class="string">&quot;danm&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;name : <span class="subst">$&#123;name&#125;</span>;age : <span class="subst">$&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认构造器只能声明一个</span></span><br><span class="line">  <span class="comment">// 不用写set方法，使用this可以直接把值赋给相应的属性</span></span><br><span class="line">  Person2(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造器</span></span><br><span class="line">  Person2.copy(Person p) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name  = p.name;</span><br><span class="line">    <span class="keyword">this</span>.age = p.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;name : <span class="subst">$&#123;name&#125;</span>;age : <span class="subst">$&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> school;</span><br><span class="line">  <span class="comment">// 普通构造器继承</span></span><br><span class="line">  Student(<span class="built_in">String</span> name,<span class="built_in">int</span> age,<span class="keyword">this</span>.school):<span class="keyword">super</span>(name,age);</span><br><span class="line">  <span class="comment">// 命名构造器的继承</span></span><br><span class="line">  Student.copy(Person p,<span class="keyword">this</span>.school):<span class="keyword">super</span>.copy(p);</span><br><span class="line"><span class="comment">// 类似构造器的重载</span></span><br><span class="line">  Student.mySchoolCopy(Person p):<span class="keyword">this</span>.copy(p,<span class="string">&#x27;mySchool&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有值都不可以改变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"><span class="comment">// cosnt修饰的构造器是常量构造器，里面的值都不许改变。因为是编译时的。</span></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> person = Person();</span><br><span class="line">  person.name = <span class="string">&quot;spawn&quot;</span>;</span><br><span class="line">  person.age = <span class="number">18</span>;</span><br><span class="line">  <span class="built_in">print</span>(person);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> person2 = Person2(<span class="string">&quot;lecon&quot;</span>,<span class="number">25</span>);</span><br><span class="line">  <span class="built_in">print</span>(person2);</span><br><span class="line">  <span class="built_in">print</span>(Person2.copy(person));</span><br><span class="line"></span><br><span class="line">  Person2 p2 = Student(<span class="string">&quot;lecon&quot;</span>,<span class="number">25</span>,<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is 和 as ;类似 instanceof和强转</span></span><br><span class="line">  <span class="keyword">if</span> (p2 <span class="keyword">is</span> Student) &#123;</span><br><span class="line">    (p2 <span class="keyword">as</span> Student).school;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Person 类的构造器后面有个<code>：</code>，那个就是初始化列表，可以给属性赋值（参考 Person 类），还可调用父类构造器。</li><li>Person2 类有两个构造器，默认构造器没有名字，和 java 中一样使用类名声明。另外还有一个<code>Person2.copy()</code> 他也是一个构造器，只不过它有名字了，同名构造器只能出现一次，不管是不是重载（貌似 Dart 没重载）。</li><li>在构造器参数列表中，如果直接使用<code>this</code>关键字，可以直接把值付给类的属性，省去了 set 方法（参考类 Person2 的默认构造器）。</li><li>在类中，所有的属性或者方法，只要带了<code>_</code>前缀，那么他就是私有的，<strong>Dart 文件之外</strong>不能访问，当前文件不同类是可以的。</li><li><code>is</code>关键字相当于<code>instanceof</code> ，<code>as</code>相当于强转。这个和 Kotlin 很像。</li><li><code>const</code>修饰构造器，代表类是编译时的。所有内容不允许改变。</li><li>类的继承使用<code>extends</code>关键字，同时 dart 也有<code>接口</code>，和 java 基本一致，不再赘述。</li><li>除了继承和接口之外，Dart 还有个<code>mixin</code>混入的概念，可以把他理解为：把其他类的东西，一股脑放到当前类中，使用<code>with</code>关键字描述。</li></ul><h4 id="minix"><a href="#minix" class="headerlink" title="minix"></a>minix</h4><p>关于 minix 参考以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class关键字换成minix，其他和class一样，只是换个名字。</span></span><br><span class="line"><span class="keyword">mixin</span> Play &#123;</span><br><span class="line">  <span class="keyword">void</span> play() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can play&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Eat &#123;</span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with关键字加入mixin类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">Play</span>,<span class="title">Eat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> age;</span><br><span class="line">  Person(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> p = Person(<span class="string">&quot;lecon&quot;</span>,<span class="number">13</span>);</span><br><span class="line">  <span class="comment">// 此时p有了Eat和Play的能力</span></span><br><span class="line">  p.play();</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="factory-构造器和多态"><a href="#factory-构造器和多态" class="headerlink" title="factory 构造器和多态"></a>factory 构造器和多态</h4><p>java 编程中，在使用多态的时候，我们可能会用到工厂方法，dart 给我们提供一个方便，使用 dart 的工厂构造器。dart 的工厂构造器也是个构造器，只不过使用 factory 修饰，他返回当前类，并且不能使用 this 关键字，示例代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person2(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// factory 构造器也是构造器，同样不能声明两个相同名字的，而且只能有一个默认</span></span><br><span class="line">  <span class="comment">// factory 没有this引用</span></span><br><span class="line">  <span class="keyword">factory</span> Person2.select(name,<span class="built_in">int</span> age,<span class="built_in">int</span> type) &#123;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Student(name,age,<span class="string">&quot;jaja&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Worker(name,age,<span class="string">&quot;lala&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// callable</span></span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">&#x27;<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;name : <span class="subst">$&#123;name&#125;</span>;age : <span class="subst">$&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> school;</span><br><span class="line"></span><br><span class="line">  Student(<span class="built_in">String</span> name,<span class="built_in">int</span> age,<span class="keyword">this</span>.school):<span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> company;</span><br><span class="line"></span><br><span class="line">  Worker(<span class="built_in">String</span> name,<span class="built_in">int</span> age,<span class="keyword">this</span>.company):<span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"><span class="comment">// 不关注Person2实现类，直接使用Person2实例化。使用factory</span></span><br><span class="line">  <span class="keyword">final</span> p1 = Person2.select(<span class="string">&quot;lecon&quot;</span>,<span class="number">23</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">final</span> p2 = Person2.select(<span class="string">&quot;lecon&quot;</span>,<span class="number">23</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(p1.runtimeType); <span class="comment">// Student</span></span><br><span class="line">  <span class="built_in">print</span>(p2.runtimeType); <span class="comment">// Worker</span></span><br><span class="line">  <span class="comment">// callable</span></span><br><span class="line">  <span class="built_in">print</span>(p1(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;234&quot;</span>,<span class="string">&quot;345&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>select</code>为 Person2 的工厂构造器，由它来返回对应的实现类。</p><h4 id="setter-和-getter"><a href="#setter-和-getter" class="headerlink" title="setter 和 getter"></a>setter 和 getter</h4><p>很多语言里面，为了方便获取属性都提供了 setter 和 getter。其实他就是个语法糖。直接使用就可以。看例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Dart 的异常也和 java 非常像。直接看例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"><span class="comment">//    throw1();</span></span><br><span class="line"><span class="comment">//    throw2();</span></span><br><span class="line"><span class="comment">//    throw3();</span></span><br><span class="line"><span class="comment">//    throw4();</span></span><br><span class="line">      throw5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw1() &#123;</span><br><span class="line">  <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw2() &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Expected at least 1 section&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw3() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;section exception <span class="subst">$&#123;e&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException <span class="keyword">catch</span>(e,s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception <span class="subst">$&#123;e&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="built_in">print</span>(s); <span class="comment">// 打印方法调用栈</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw4() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception&#x27;</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// 重抛</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw5() &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;I am finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dart 可以直接抛出默认异常，<code>throw &#39;Expected at least 1 section&#39;;</code></li><li>使用<code>on</code>来匹配异常类型，<code>on FormatException</code></li><li>使用<code>catch</code>来获取异常变量，<code>catch(e,s)</code>它有一个默认参数和可选参数。分别为信息和调用栈。</li><li>使用<code>rethrow</code>重新抛出异常</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>dart 的异步和 JavaScript ES6 差不多，使用<code>await</code>和<code>async</code>，只不过 ES6 中的 Promise 变成了 Future。目前比较流行的解决方案都是这个，比如 Python,Kotlin 都这么使用。一般在网络请求或者数据库操作时候使用，就像 java 的多线程基础版吧。</p><p>异步这块东西有点多，而且很重要，直接贴官方地址。<a href="https://www.dartlang.org/guides/libraries/library-tour#future">https://www.dartlang.org/guides/libraries/library-tour#future</a></p><p>异步中有两个很重要的接口：<code>Future</code>和<code>Stream</code>。贴出地址，这两个一定要弄明白。<a href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming">https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming</a></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>Dart 的生成成器和其他语言里面的生成器差不多，分为<code>同步</code>和<code>异步</code>两种。同步生成器结构是<code>Iterable</code>，异步生成器接口是<code>Stream</code>。流程控住使用<code>async*</code>（异步）和<code>sync*</code>（同步）声明，使用<code>yield</code>流程控制，每一次<code>yield</code>都会给列表生成一个值，也就是说生成器返回结果的数据结构可以当列表使用。以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(naturalsTo(<span class="number">10</span>)); <span class="comment">// (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line">  <span class="built_in">print</span>(naturalsDownFrom(<span class="number">10</span>)); <span class="comment">// (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span></span><br><span class="line">  asynchronousNaturalsTo(<span class="number">10</span>)</span><br><span class="line">    .toList() <span class="comment">// toList把异步转为同步</span></span><br><span class="line">    .then((res) &#123;</span><br><span class="line">      <span class="built_in">print</span>(res); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsTo(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步生成器</span></span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归性质的生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅导入foo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排除foo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:greetings/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure><h4 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h4><p>Dart 也有<code>null</code>类型，并且和其他语言类似，Dart 也是用<code>？</code>来解决空问题。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> a = <span class="keyword">null</span>;</span><br><span class="line">  <span class="built_in">print</span>(a != <span class="keyword">null</span> ? a : <span class="string">&quot;b&quot;</span>); <span class="comment">// 等同于下边,dart也支持三元运算符</span></span><br><span class="line">  <span class="built_in">print</span>(a ?? <span class="string">&quot;b&quot;</span>); <span class="comment">// 打印 b</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> p = <span class="keyword">null</span>;</span><br><span class="line">  <span class="built_in">print</span>(p?.toString()); <span class="comment">//打印null，而不会空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="..运算符"></a><code>..</code>运算符</h4><p>Dart 的联级运算符<code>..</code>很有意思，很实用的语法糖，直接看代码你就明白了。<code>Builder</code>大法好。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   <span class="comment">// 联级运算符</span></span><br><span class="line"><span class="keyword">final</span> p = Person()</span><br><span class="line">  ..username = <span class="string">&quot;lecon&quot;</span></span><br><span class="line">    ..password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    ..setSex(<span class="keyword">true</span>);</span><br><span class="line">  <span class="built_in">print</span>(p); <span class="comment">// Username: lecon; Password: 123456; Sex: true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _username;</span><br><span class="line">  <span class="built_in">String</span> _password;</span><br><span class="line">  <span class="built_in">bool</span> _sex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> username(<span class="built_in">String</span> username)  =&gt; <span class="keyword">this</span>._username = username;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> password(<span class="built_in">String</span> password)  =&gt; <span class="keyword">this</span>._password = password;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setSex(<span class="built_in">bool</span> sex)  =&gt; <span class="keyword">this</span>._sex = sex;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;Username: <span class="subst">$&#123;<span class="keyword">this</span>._username&#125;</span>; Password: <span class="subst">$&#123;<span class="keyword">this</span>._password&#125;</span>; Sex: <span class="subst">$&#123;<span class="keyword">this</span>._sex&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h4><p>这个和 C++里边的内联函数基本差不多。<br>官方例子 <a href="https://www.dartlang.org/guides/language/language-tour#typedefs">https://www.dartlang.org/guides/language/language-tour#typedefs</a></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>Dart 注释分为三种，单行注释和多行注释和 java 一致。doc 注释使用 <code>///</code>表示。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A domesticated South American camelid (Lama glama).</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Andean cultures have used llamas as meat and pack</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">animals since pre-Hispanic times.</span></span></span><br></pre></td></tr></table></figure><p>##最后<br>临时总结，难免有错误，请多多指出，我会在第一时间改正。</p><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://gist.github.com/leconio/73bd75eef9530ff76ac59e09b1331865">https://gist.github.com/leconio/73bd75eef9530ff76ac59e09b1331865</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先本文是通过对比其他语言（主要是 java）快速入门&lt;/p&gt;</summary>
    
    
    
    <category term="玩儿" scheme="https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>开启BBR搭建ss-server</title>
    <link href="https://leconio.github.io/2019/06/10/%E5%BC%80%E5%90%AFBBR%E6%90%AD%E5%BB%BAss-server/"/>
    <id>https://leconio.github.io/2019/06/10/%E5%BC%80%E5%90%AFBBR%E6%90%AD%E5%BB%BAss-server/</id>
    <published>2019-06-10T21:13:09.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这次的教程主要分为以下几个部分：</p></blockquote><ol><li>搭建 Shadowsocks-libev 服务端</li><li>配置防火墙</li></ol><span id="more"></span><p>接着上回说，现在我们 ssh 到搬瓦工服务器。</p><h2 id="检查-bbr"><a href="#检查-bbr" class="headerlink" title="检查 bbr"></a>检查 bbr</h2><p>第一件事儿就是检查有没有开启 bbr 内核，bbr 对于 VPS 的提速上一节已经说过了，非常大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>如果显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno</span><br></pre></td></tr></table></figure><p>代表 bbr 已经开启。如果结果中没有 bbr 也不用担心，我在上一篇文章放出了一个安装 bbr 和锐速的脚本，可以直接使用。</p><h2 id="安装-Shadowsocks-服务器"><a href="#安装-Shadowsocks-服务器" class="headerlink" title="安装 Shadowsocks 服务器"></a>安装 Shadowsocks 服务器</h2><p>前段时间秋大的博客宣布告别，这意味着高质量的一键安装脚本越来越少。虽然搬瓦工提供一件安装选项，但可定制化不高，所以我建议大家使用托管在 github 的原始项目，理由是可以保持功能最新，遇到问题也可以通过 issues 而得到迅速解决，<a href="https://github.com/shadowsocks/shadowsocks-libev">shadowsocks-libev</a>。<br><strong>首先安装依赖项目</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y</span><br></pre></td></tr></table></figure><p><code>shadowsocks-libev</code> 托管在 dnf 的 copr 仓库内，默认的 centos7 是不带这个仓库。这里我们安装 dnf 和 copr 仓库。<br><strong>1. 安装 dnf 和 copr 仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install dnf</span><br><span class="line">dnf install dnf-plugins-core</span><br><span class="line">dnf install dnf-plugins-copr</span><br></pre></td></tr></table></figure><p><strong>2. 开启 copr 的<code>shadowsocks-libev</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf copr enable librehat&#x2F;shadowsocks</span><br></pre></td></tr></table></figure><p><strong>3. 安装 <code>shadowsocks-libev</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf update</span><br><span class="line">dnf install shadowsocks-libev</span><br></pre></td></tr></table></figure><p>到此为止，如果没有出现什么问题，安装就算完成了，现在执行下面的命令来测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-server -h</span><br></pre></td></tr></table></figure><h2 id="配置服务端参数"><a href="#配置服务端参数" class="headerlink" title="配置服务端参数"></a>配置服务端参数</h2><p>上面说到，通过执行 ss-server 可以启动一个 ss 服务器，但是，在实际使用的时候，我们通常设置自己使用的参数，下面的例子是一组最简单的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-server -p 8989 -k 123456 -m chacha20 --fast-open</span><br></pre></td></tr></table></figure><p>其中-p 是对外开放的端口，-k 是密码，-m 是加密方式，chacha20 是一种非常优秀的加密方式呦，你懂得。–fast-open 开启 TCP 快速打开模式。<br>你可以直接在 VPS 的执行上面的命令，但是这是一个阻塞命令，我们可以使用 nohup 来切换到后台运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ss-server -p 8989 -k 123456 -m chacha20 --fast-open &amp;</span><br></pre></td></tr></table></figure><p><strong>看一下我们的 ss-server 是否启动成功</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过pid查看ss是否启动</span><br><span class="line">ps -ef|grep ss-server</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过端口查看ss是否启动</span><br><span class="line">iptables -xvn -L|grep 8989</span><br></pre></td></tr></table></figure><p><strong>别忘了防火墙</strong><br>在上面的参数中，ss 对外开放的端口是 8989。那么我们通过 Centos7 的 firewalld-cmd 防火墙放行这个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br><span class="line">firewall-cmd --set-default-zone&#x3D;public</span><br><span class="line">firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;ssh</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;tcp</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;udp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>上面开启了 ssh 服务使用的端口和 8989 端口，如果你还有需要使用的端口，请参考这篇文章<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">How To Set Up a Firewall Using FirewallD on CentOS 7</a><br>好啦！测试一下我们的 8989 通不通吧，在本地电脑 telnet 到 8989</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [domain name or ip] 8989</span><br></pre></td></tr></table></figure><p>空白代表通了。</p><p>（未完待续）<br>下一篇讲述怎么搭建客户端，以及一些小技巧。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这次的教程主要分为以下几个部分：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;搭建 Shadowsocks-libev 服务端&lt;/li&gt;
&lt;li&gt;配置防火墙&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="玩儿" scheme="https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>破解公司 Mac 电脑的 jamf 限制，让 Mac 可以共享 Wifi</title>
    <link href="https://leconio.github.io/2019/06/05/%E7%A0%B4%E8%A7%A3%E5%85%AC%E5%8F%B8Mac%E7%9A%84Wifi%E5%85%B1%E4%BA%AB%E9%99%90%E5%88%B6/"/>
    <id>https://leconio.github.io/2019/06/05/%E7%A0%B4%E8%A7%A3%E5%85%AC%E5%8F%B8Mac%E7%9A%84Wifi%E5%85%B1%E4%BA%AB%E9%99%90%E5%88%B6/</id>
    <published>2019-06-05T16:49:06.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。</p><span id="more"></span><p>这些功能的限制都是通过 Mac 的 jamf 管理的，破解限制需要 Root 权限。<br>首先我们先找到 jamf 这个可执行文件，他一般在 <code>/usr/local/jamf/</code> 下面。也可以通过 find 命令查找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find /usr/<span class="built_in">local</span> |grep jamf</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/jamf</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/jamfAgent</span><br><span class="line">/usr/<span class="built_in">local</span>/jamf</span><br><span class="line">/usr/<span class="built_in">local</span>/jamf/bin</span><br><span class="line">/usr/<span class="built_in">local</span>/jamf/bin/jamf</span><br></pre></td></tr></table></figure><p>我的 jamf 可执行文件在 <code>/usr/local/jamf/bin</code> 下面。那么开始破解：</p><p>首先通过执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo jamf removeMDMProfile</span><br></pre></td></tr></table></figure><p>移除 jamf 的限制，这时候受限制的功能就可以使用了。但是，过一段时间之后你会发现又恢复原来的状态了。那么应该怎么解决呢？<br>我们做一个伪装的 jamf 吧！这时候系统调用 <code>jamf</code> 的时候，就会调用我们伪装的文件，不让我们的破解失效。</p><ol><li>首先备份原始文件，这里要把整个 bin 目录备份。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/jamf</span><br><span class="line">mkdir backup</span><br><span class="line">mv bin backup</span><br></pre></td></tr></table></figure><ol start="2"><li>新建一个伪装 jamf 的纯文本文档，输入以下信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo &#39;dummy&#39; &gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><ol start="3"><li>替换原有的 jamf</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;</span><br><span class="line">sudo mv jamf &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;</span><br><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;jamf</span><br></pre></td></tr></table></figure><p>然后重启你的 Mac ，大功告成！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。&lt;/p&gt;</summary>
    
    
    
    <category term="玩儿" scheme="https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos7增加swap分区大小</title>
    <link href="https://leconio.github.io/2018/12/21/Centos7%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
    <id>https://leconio.github.io/2018/12/21/Centos7%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</id>
    <published>2018-12-21T13:57:17.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>如何增加 Centos7 的 swap 分区大小</p><span id="more"></span><p>1.添加 swap 分区<br>dd if=/dev/zero of=/var/swapfile bs=1024 count=4096k</p><p>2.执行完毕，对交换文件格式化并转换为 swap 分区：<br>mkswap /var/swapfile</p><p>3.挂载并激活分区：<br>swapon /var/swapfile</p><p>4 赋权限<br>chmod -R 0600 /var/swapfile</p><p>5.设置开机自动挂载该分区：<br>vi /etc/fstab<br>在 fstab 文件末尾追加如下内容后:wq!保存即可：<br>/var/swapfile swap swap defaults 0 0</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何增加 Centos7 的 swap 分区大小&lt;/p&gt;</summary>
    
    
    
    <category term="黑洞" scheme="https://leconio.github.io/categories/%E9%BB%91%E6%B4%9E/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Caddy代理Bitbucket服务器</title>
    <link href="https://leconio.github.io/2018/12/21/%E4%BD%BF%E7%94%A8Caddy%E4%BB%A3%E7%90%86Bitbucket%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://leconio.github.io/2018/12/21/%E4%BD%BF%E7%94%A8Caddy%E4%BB%A3%E7%90%86Bitbucket%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2018-12-21T13:55:53.000Z</published>
    <updated>2021-03-04T05:58:31.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。</p></blockquote><span id="more"></span><h2 id="Bitbucket"><a href="#Bitbucket" class="headerlink" title="Bitbucket"></a>Bitbucket</h2><p>Bitbucket 虽然不是一个免费的版本管理工具，但是本身体验还是很好的，即使付费版本个人使用也很便宜。基于 Java 实现，执行效率当然说的过去。相比于 gitlab 这种需要内存至少 2G 的怪兽，至少是一个选择，而却他不容易宕机，但是他的最大魅力还是配置比较简单。</p><h5 id="下载方式，官网找下载链接，直接-wget"><a href="#下载方式，官网找下载链接，直接-wget" class="headerlink" title="下载方式，官网找下载链接，直接 wget"></a>下载方式，官网找下载链接，直接 wget</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;bitbucket.org&#x2F;product&#x2F;download</span><br></pre></td></tr></table></figure><h2 id="Caddy"><a href="#Caddy" class="headerlink" title="Caddy"></a>Caddy</h2><p>使用 Caddy 之前，一直使用 Nginx 作为反向代理服务器，但是 Nginx 配置比较复杂，本身又基于服务模式启动，对于玩家不太友好。Caddy 解决了这些问题，下载好，只需要要执行一个命令就可以启动服务器，全世界都能看到你了。主要是，他可以自动申请 ssl，免去自己申请。</p><h5 id="下载方式："><a href="#下载方式：" class="headerlink" title="下载方式："></a>下载方式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;getcaddy.com | bash -s personal</span><br></pre></td></tr></table></figure><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>Atlassian 家的软件启动都非常简单。下载好之后，给它一个可执行的权限，然后<code>./</code>他就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x atlassian-bitbucket-5.16.0-x64.bin</span><br><span class="line">.&#x2F;atlassian-bitbucket-5.16.0-x64.bin</span><br></pre></td></tr></table></figure><p>这个步骤最好给它 Root 权限。<br>安装完成之后，在<code>/opt</code>下面你可以找到他。到<code>bin</code>目录下，启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;atlassian&#x2F;bitbucket&#x2F;5.16.0&#x2F;bin</span><br><span class="line">.&#x2F;start-bitbucket.sh</span><br></pre></td></tr></table></figure><p>然后，访问<code>youip:7990</code>。现在大概可以配置这台 git 服务器了。<br>一台电脑只有一个 80 或者 443 端口，不同的服务想使用同一个端口就需要反向代理服务器了。<br>Caddy 需要一个 Caddyfile 文件，可以理解为 Caddy 的描述文件，随便创建一个目录，然后新建这个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~&#x2F;www</span><br><span class="line">cd ~&#x2F;www</span><br><span class="line">vi Caddyfile</span><br></pre></td></tr></table></figure><p>在这个文件中粘贴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git.lecon.io &#123;</span><br><span class="line">    proxy &#x2F; http:&#x2F;&#x2F;127.0.0.1:7990 &#123;</span><br><span class="line">        header_upstream Host &#123;host&#125;</span><br><span class="line">        header_upstream X-Real-IP &#123;remote&#125;</span><br><span class="line">        header_upstream X-Forwarded-For &#123;remote&#125;</span><br><span class="line">        header_upstream X-Forwarded-Server &#123;host&#125;</span><br><span class="line">        header_upstream X-Forwarded-Proto &#123;scheme&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思大概就是说，把客户端的环境信息原封不动的发送给被代理对象。<br>在当前 Caddyfile 目录中执行<code>caddy</code>。输入一下邮箱，现在访问你的网址，可以直接使用了。这个命令会阻塞当前 session，所以最好叫他到后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup caddy &amp;</span><br></pre></td></tr></table></figure><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>Caddy 会默认把 http 流量转发到 https 上，给客户端发送一个 302，重定向到 https 网址，这样的话就会出现一个问题，我在打开 Bitbucket 网页，然后请求外部网页，就会发生跨域问题，导致 Webhook 功能不能使用。<br>现在需要配置一下 Bitbucket，找到<code>bitbucket.properties</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;|grep bitbucket.properties</span><br></pre></td></tr></table></figure><p>然后加入下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;7990</span><br><span class="line">server.secure&#x3D;true</span><br><span class="line">server.scheme&#x3D;https</span><br><span class="line">server.proxy-port&#x3D;443</span><br><span class="line">server.proxy-name&#x3D;git.lecon.io</span><br></pre></td></tr></table></figure><p>重启一下 Bitbucket 服务器，Webhook 等功能可以正常使用。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="玩儿" scheme="https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
</feed>
