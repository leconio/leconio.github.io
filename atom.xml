<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lecon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lecon.io/"/>
  <updated>2021-03-03T13:22:46.718Z</updated>
  <id>https://lecon.io/</id>
  
  <author>
    <name>lecon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用frp访问公司内部网络</title>
    <link href="https://lecon.io/2021/03/03/%E4%BD%BF%E7%94%A8frp%E8%AE%BF%E9%97%AE%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C/"/>
    <id>https://lecon.io/2021/03/03/%E4%BD%BF%E7%94%A8frp%E8%AE%BF%E9%97%AE%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C/</id>
    <published>2021-03-03T13:20:56.000Z</published>
    <updated>2021-03-03T13:22:46.718Z</updated>
    
    <content type="html"><![CDATA[<p>观看之前，建议你有 ssh 和简单的 shell 使用经验。</p><span id="more"></span><h1 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h1><blockquote><p>观看之前，建议你有 ssh 和简单的 shell 使用经验。</p></blockquote><p>顾名思义，这是一个通过内网穿透自建 vpn 来访问公司内网的教程。说到内网穿透、vpn 都不是什么新鲜的概念，但是这些工具组合起来确实有很多好玩的地方。在这里，就是他们其中的一种组合游戏。<br>好戏开始之前，我们先提出几个疑问，让我猜猜你想的对不对。</p><pre><code>1. 我在家里可以访问公司内网吗，比如打卡，收发邮件之类的？2. 我需要哪些必备的东西呢？3. frp是个什么工具？</code></pre><p>那么，带着疑问我们开始吧！</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><p>一句话来说就是，通过 frp 把公司计算机的 ssh 暴露出来，个人计算机使用公司计算机 ssh 的 socks5 代理进行上网。</p><p>首先介绍一下 frp 这个软件，经常做微信开发的小伙伴应该有接触到，它是搞内网穿透的。在调试公众号或者小程序接口的时候，需要把开发服务器映射到公网上，这样微信服务器才能成功回调到开发者计算机。但是，我们开发计算机在局域网呀，在使用 NAT 转换之后，公网服务器无法直接访问局域网计算机；也就是说，我可以访问互联网，但是互联网无法主动访问我。frp 就是解决这个问题的，它把我自己的计算机的 web 服务放到公网上，然后我们就可以从互联网访问到它。</p><p>那么话说回来了，这和今天这个话题有什么联系呢？我们要让个人计算机使用公司的计算机网络进行网络访问，就必须把公司的计算机暴露在互联网当中。如下图：<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15485604883245.jpg" alt=""></p><p><strong><em>其实你已经注意到了：把公司计算机直接暴露在公网，会不会不安全呀？当然会，实际使用过程中，一定要按需开启，并且使用安全验证。</em></strong></p><p>frp 不仅仅能把 web 服务暴露在公网，而且还可以把 ssh 服务暴露在公网上。也就是说，我可以通过个人计算机直接 ssh 公司的内网的计算机。</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>代理我们使用的是 ssh 的 socks5 代理，ssh 有这样一个功能，就是把 ssh 服务器当成一个 socks5 正向的代理，把监听到 socks5 服务端口的流量转发到 ssh 服务器上。就可以实现个人计算机通过公司内网计算机进行上网了。</p><p><em>下面介绍需要用到的设备以及环境。</em></p><h1 id="原材料"><a href="#原材料" class="headerlink" title="原材料"></a>原材料</h1><p>上面说到，要想实现必须有三台计算机。首先，<strong>公司的个人电脑</strong>和<strong>家中的电脑</strong>是其中两个，还需要一个<strong>公网电脑</strong>进行数据中转。</p><h3 id="流量转发端"><a href="#流量转发端" class="headerlink" title="流量转发端"></a>流量转发端</h3><p>流量转发端是公网中转计算机，它是什么呢？简言之就是有独立 ip 的服务器，这个很容易就买到了，比如阿里云或者腾讯云什么的，很多小伙伴在双 11 和和双 12，被他们冲了一波业绩吧！现在用起来吧，我这里环境使用 Centos7，使用 Ubuntu 的小伙伴也关系，只是防火墙设置不同而已。</p><h3 id="流量提供端"><a href="#流量提供端" class="headerlink" title="流量提供端"></a>流量提供端</h3><p>流量提供端为公司的计算机，必须支持 ssh 服务，Linux 和 Mac 原生支持了，Windows 需要额外下载软件进行支持，比如 Windows10 的内置 Ubuntu，我这里使用 Mac 系统。</p><h3 id="流量消费端"><a href="#流量消费端" class="headerlink" title="流量消费端"></a>流量消费端</h3><p>流量消费端为个人计算机，可以是 Mac、Linux，或者 Windows，Android，后两个需要额外软件，iOS 没有试过。我这里使用 Mac 系统。</p><blockquote><p>我个人不建议使用 Windows 最为搭建这套环境，Windows 下的 Linux 子环境实在是难以折腾，即使通过虚拟机或者 bash 等折腾成功，还要考虑网络问题。</p></blockquote><h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><p>搭建过程分为以下几步。</p><pre><code>1. 在中转服务器和公司计算机之间搭建frp服务。2. 个人计算机可以通过ssh访问公司计算机。3. 把个人计算机的ssh流量作为局部代理4. 设置局部代理</code></pre><p>这样一来工作就清晰了起来！</p><h3 id="1-搭建-frp-服务"><a href="#1-搭建-frp-服务" class="headerlink" title="1. 搭建 frp 服务"></a>1. 搭建 frp 服务</h3><p>frp 分为客户端和服务端两个软件，我们可以从 <a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a> 获得（他们在同一个压缩内）。<strong>其中 frps 是服务器端，frpc 是客户端。把 frps 放到中转服务器，把 frpc 放到公司计算机。</strong></p><p>同时，不管设计 frps 还是 frpc，都仅仅需要一个软件和一个配置文件即可运行。</p><h4 id="搭建中转服务器的-frps-服务（操作中转服务器）"><a href="#搭建中转服务器的-frps-服务（操作中转服务器）" class="headerlink" title="搭建中转服务器的 frps 服务（操作中转服务器）"></a>搭建中转服务器的 frps 服务（操作中转服务器）</h4><p>这一步的目的是建立 frp 服务器。首先 ssh 到中转服务器，下载 frp 软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.23.2&#x2F;frp_0.23.2_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.23.2_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>得到解压的文件，我们只需关注 frps 和 frps.ini 这两个，其他的可以删除。<br>编辑 frps.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br></pre></td></tr></table></figure><p>然后运行 frp 服务端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure><p>当然，为了方便使用，也可以后台运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;frpc -c .&#x2F;frpc.ini &amp;</span><br></pre></td></tr></table></figure><h4 id="搭建公司计算机的-frpc-服务（操作公司计算机）"><a href="#搭建公司计算机的-frpc-服务（操作公司计算机）" class="headerlink" title="搭建公司计算机的 frpc 服务（操作公司计算机）"></a>搭建公司计算机的 frpc 服务（操作公司计算机）</h4><p>这一步要打通<strong>公司计算机</strong>和<strong>中转服务器</strong>之间的连接。在这之前，首先要确定公司的计算机时候开启 ssh 服务器。Linux 默认都会开启，Windows 用户只能去找软件来使用，其中 Bitvise SSH Server 还不错，使用起来也比较简单，只是收费。Mac 系统参考如下：</p><p><strong>系统偏好设置 -&gt; 共享 -&gt; 远程登录</strong>。勾选上，然后在右边添加自己用户。<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486505796374.jpg" alt="-w340"><br>设置好 ssh 服务之后，请下载 frp 客户端软件。这里需要 frpc 和 frpc.ini 这两个文件，其他都可以删除掉。</p><blockquote><p>下载时候要选择好对应平台再下载。客户端和服务端如果系统平台不一样，就不能用同一份（虽然客户端和服务端在同一个文件夹中）。</p></blockquote><p>然后编辑 fric.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; x.x.x.x</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000</span><br></pre></td></tr></table></figure><p>注意，这里虽说是在设置公司计算机的客户端配置，但是涉及的到两个端口<code>7000</code>和<code>6000</code>，在中转服务器中也需要<strong>添加防火墙例外规则</strong>，腾讯云或则阿里云好像还要添加安全组。</p><p>其中，<code>x.x.x.x</code>为你中转服务器的公网 ip。<code>server_port</code>是中转服务器和公司服务器通信的端口，<code>remote_port</code>是 ssh 的虚拟端口，我们连接时候指定的端口就是它。其他的参数都无关紧要，具体可以了解 <a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a> 。</p><p>现在启动公司计算机的 frp 客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure><p>到这里，主要工作基本上已经完成了，现在就来测试一下是否可以从个人计算机通过 ssh 连接到公司的计算机吧。</p><h3 id="2-SSH-到公司计算机（操作个人计算机）"><a href="#2-SSH-到公司计算机（操作个人计算机）" class="headerlink" title="2. SSH 到公司计算机（操作个人计算机）"></a>2. SSH 到公司计算机（操作个人计算机）</h3><p>如果使用的是 mac 或者 linux 可以直接使用下面的命令，连接到公司计算机。如果是 windows，需要下载 putty 或者 linux 子系统等 ssh 软件（后文提到）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort&#x3D;6000 [用户名]@x.x.x.x</span><br></pre></td></tr></table></figure><p>其中，x.x.x.x 是你中转服务器的公网 ip。注意这里一定要加上面指定的端口，不然会连接到中转服务器的 ssh 服务。不出什么问题，就可以连接到公司计算机了。</p><blockquote><p>在这个过程中，如果很久都没连接上，或者被远程主动关闭，请检查防火墙的设置。我们可以使用 telnet 命令测试远程端口是否开启。</p></blockquote><p>教程到这里，好像和 vpn 好像还没有什么太大的关系，仅仅是可以控制公司的计算机而已。不要忘记，ssh 有一个很好的功能，就是把远程服务器的流量，变成本地计算机的 socks5 代理。</p><h3 id="3-设置-ssh-的-socks5-代理（操作个人计算机）"><a href="#3-设置-ssh-的-socks5-代理（操作个人计算机）" class="headerlink" title="3. 设置 ssh 的 socks5 代理（操作个人计算机）"></a>3. 设置 ssh 的 socks5 代理（操作个人计算机）</h3><p>好的，现在可以按 control+c 停止连接。然后，Linux 用户和 Mac 用户可以直接输入以下命令直接开启 sock5 隧道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 [公司计算机账户]@[中转服务里ip]</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 spawn@192.168.2.1</span><br></pre></td></tr></table></figure><p>注意以上命令，这里又多出一个 1080 的端口，这个端口是为本地开的。任何把代理端口指向这个位置的连接，都可以使用这个代理，所以这里要记住这个端口。</p><p>如果你想让局域网其他电脑也可以访问，那么把 127.0.0.1 换成 0.0.0.0。</p><blockquote><p>注意：ssh 的 sock5 代理如果长时间不使用会自动断开连接，当然，使用<code>autossh</code>可以解决这个问题。</p></blockquote><p>Windows 用户需要额外的软件，推荐使用 putty。操作步骤如下：打开 putty<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486510122980.jpg" alt="-w334"><br>其中 x.x.x.x 为中转服务 ip，端口填写 6000</p><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486510241269.jpg" alt="-w343"><br>按照上图操作步骤操作<br>然后检查路由表，看看是否正常开启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -a</span><br></pre></td></tr></table></figure><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486510398204.jpg" alt="-w733"></p><p>到此 Windows 可以开启一个端口为 1080 的 sock5 隧道<br>开启 sock5 隧道之后，怎么能检测一下呢？打开一个新的 Shell，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">curl cip.cc</span><br></pre></td></tr></table></figure><p>注意，上面的 1080 就是之前预留的端口，地址 127.0.0.1 指向本地。接下来使用上面命令看一看公网 ip 是不是和公司计算机的一样。（PS. 公司计算机也可以输入这个命令查看，或者直接百度关键字 ip。如果相同，那么以上过程就全部成功了！</p><blockquote><p>插个题外话，如果把公司计算机去掉，直接连接中转服务器的 ssh 服务的话，你懂得~。ssh 比 pptp 和 l2tp 要爽哦，关键日子那几天，纸飞机隧道都不可用，全靠它呢！！！</p></blockquote><p>接下来，有了 sock5 代理，按理说文章应该可以结束了。但是毕竟还没有看到效果，那么接下来简单说说它的几种食用方式，这个过程可以任意发挥，没有固定方式！</p><h3 id="通过局部代理上网"><a href="#通过局部代理上网" class="headerlink" title="通过局部代理上网"></a>通过局部代理上网</h3><p>上面我们说到，如何把 ssh 流量变成 socks5 局部代理，那么现在就是怎么使用这个局部代理了。</p><h4 id="命令行代理"><a href="#命令行代理" class="headerlink" title="命令行代理"></a>命令行代理</h4><p>这种代理方式只在当前 session 生效，一旦关闭当前命令行，就会失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启方式 export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">关闭方式 export ALL_PROXY&#x3D;</span><br><span class="line">检验方式 curl cip.cc</span><br></pre></td></tr></table></figure><h4 id="Mac-全局代理"><a href="#Mac-全局代理" class="headerlink" title="Mac 全局代理"></a>Mac 全局代理</h4><p><strong>系统偏好设置 -&gt; 网络 -&gt; 高级 -&gt; 代理 -&gt; socks 代理</strong> 勾选这个<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486512763854.jpg" alt="-w433"><br>点击确定。</p><h4 id="Chrome-插件分网址代理"><a href="#Chrome-插件分网址代理" class="headerlink" title="Chrome 插件分网址代理"></a>Chrome 插件分网址代理</h4><p>推荐使用插件 SwitchyOmega，由于本教程不是讲局部代理使用方式，直接贴这个插件的使用教程 <a href="https://github.com/FelisCatus/SwitchyOmega">https://github.com/FelisCatus/SwitchyOmega</a> 。<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2021/03/03/15486514601716.jpg" alt="-w473"><br>使用<code>SwitchyOmega</code>可以针对不同网页使用不同的代理方式，比如说，1080 端口是访问公司内网的，1088 端口是土啬的。它还可以破除公司对于某些网站的限制，同时也代理就不用切来切去了，十分方便。</p><h4 id="Proxifier-分应用代理"><a href="#Proxifier-分应用代理" class="headerlink" title="Proxifier 分应用代理"></a>Proxifier 分应用代理</h4><p>使用 SwitchyOmega 可以在访问不同网站的时候使用不同的代理设置，那么 Proxifier 就可以针对于不同的应用使用不同的代理，甚至切断互联网连接。或者我们可以把上面教程反过来玩，然公司服务器当个人计算机，家中的电脑扮演公司计算机的角色。使某些 App 走家中的流量，就可以简单破除公司对于某些 App 的网路限制，比如微信或者音乐视频类软件，但是要注意 dns 的设置。</p><p>它是一个十分优秀的软件，但是需要付费。如果是针对外企用户需要频繁切换网络的用户来说，它的确是一个福音。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>一般来说，公司的网络安全部都不会允许把公司计算机暴露在公网之下，本文只讨论技术，大家好好玩儿~</p><h1 id="2021-年-3-月-2-日更新"><a href="#2021-年-3-月-2-日更新" class="headerlink" title="2021 年 3 月 2 日更新"></a>2021 年 3 月 2 日更新</h1><p>使用<code>nps</code>后者<code>goproxy</code>过程会更简单 - -</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观看之前，建议你有 ssh 和简单的 shell 使用经验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="玩儿" scheme="https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Android的Binder的调用方面</title>
    <link href="https://lecon.io/2021/03/03/Android%E7%9A%84Binder%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2/"/>
    <id>https://lecon.io/2021/03/03/Android%E7%9A%84Binder%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2/</id>
    <published>2021-03-03T13:07:07.000Z</published>
    <updated>2021-03-03T13:08:12.288Z</updated>
    
    <content type="html"><![CDATA[<p>Android 的 Binder 的调用方面</p><span id="more"></span><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>从 Binder 的远程方法调用来看，Proxy 是调用端，Stub 是被调用端。由 AIDL 的 Interface 实现类，可以看出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.util.List&lt;com.leconio.aidlsender.Person&gt; getPersons() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    java.util.List&lt;com.leconio.aidlsender.Person&gt; _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getPersons, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefaultImpl().getPersons();</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.createTypedArrayList(com.leconio.aidlsender.Person.CREATOR);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取两个 Parcel，一个用于传递数据，一个用于接收数据。每个 Parcel 中都有一个<code>mNativePtr</code>，是个 long 类型，其实他是 JNI 中的 Parcel，由 reinterpret_cast 转换而来。也就是说，Java 层的 Parcel 包裹着 JNI 层的 Parcel。Parcel 是在一个 Parcel 池中获取，这个池大小是 6。<br><code>mNativePtr</code> 会在 CPP 代码中 Parcel 初始化的时候被初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ParcelRef&gt; parcelRef = ParcelRef::create();</span><br><span class="line">    parcelRef-&gt;incStrong(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(android_os_Parcel_create));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(<span class="keyword">static_cast</span>&lt;Parcel *&gt;(parcelRef.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>mRemote</code>的实现类是 Java 层的<code>ProxyBinder</code>，这个地方就调用到了 ProxyBinder 中的<code>transact</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AppOpsManager.resumeNotedAppOpsCollection(prevCollection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transactListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            transactListener.onTransactEnded(session);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tracingEnabled) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到了 cpp 层的<code>transactNative</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_os_BinderProxy</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jboolean replyObjOwnsNativeParcel,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); <span class="comment">// 获取BPBinder</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags); <span class="comment">// 由BPBinder再次传递</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">    mHandle, code, data, reply, flags); <span class="comment">// 由IPCThreadState传递给驱动</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有 reply 的话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply); <span class="comment">// 等待回复</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// 无限循环等待结果</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Processing waitForResponse Command: &quot;</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> BR_REPLY: <span class="comment">// 如果返回消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer); <span class="comment">// 设置返回值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>reply</code> 是 Parcel。我们看看<code>Parcel::ipcSetDataReference</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parcel::ipcSetDataReference</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freeData();</span><br><span class="line"></span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data); <span class="comment">// 设置值</span></span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects);</span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;%s: bad object offset %&quot;</span> PRIu64 <span class="string">&quot; &lt; %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> flat_binder_object* flat</span><br><span class="line">            = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> flat_binder_object*&gt;(mData + offset);</span><br><span class="line">        <span class="keyword">uint32_t</span> type = flat-&gt;hdr.type;</span><br><span class="line">        <span class="keyword">if</span> (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE ||</span><br><span class="line">              type == BINDER_TYPE_FD)) &#123;</span><br><span class="line">            <span class="comment">// We should never receive other types (eg BINDER_TYPE_FDA) as long as we don&#x27;t support</span></span><br><span class="line">            <span class="comment">// them in libbinder. If we do receive them, it probably means a kernel bug; try to</span></span><br><span class="line">            <span class="comment">// recover gracefully by clearing out the objects, and releasing the objects we do</span></span><br><span class="line">            <span class="comment">// know about.</span></span><br><span class="line">            android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">&quot;135930648&quot;</span>);</span><br><span class="line">            ALOGE(<span class="string">&quot;%s: unsupported type object (%&quot;</span> PRIu32 <span class="string">&quot;) at offset %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                  __func__, type, (<span class="keyword">uint64_t</span>)offset);</span><br><span class="line">            releaseObjects();</span><br><span class="line">            mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中，设置了返回值 mData。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 的 Binder 的调用方面&lt;/p&gt;
    
    </summary>
    
    
      <category term="黑洞" scheme="https://lecon.io/categories/%E9%BB%91%E6%B4%9E/"/>
    
    
  </entry>
  
  <entry>
    <title>Dart对比java快速入门</title>
    <link href="https://lecon.io/2020/03/03/Dart%E5%AF%B9%E6%AF%94java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://lecon.io/2020/03/03/Dart%E5%AF%B9%E6%AF%94java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-03T13:38:18.000Z</published>
    <updated>2021-03-03T13:38:43.544Z</updated>
    
    <content type="html"><![CDATA[<p>首先本文是通过对比其他语言（主要是 java）快速入门</p><span id="more"></span><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>首先本文是通过对比其他语言（主要是 java）快速入门，建议您至少要熟悉一门静态语言或者动态语言。Dart 和 java 以及 C#都差不多，基本上不用学习可以直接使用，从这里可以你可以了解 Dart 有些特别之处。</p><p>首先从一段代码入门吧：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    printTest(<span class="string">&#x27;hello <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> printTest(<span class="built_in">String</span> variableInteger) &#123;</span><br><span class="line">  <span class="built_in">print</span>(variableInteger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，Dart 语言主入口是<code>main函数</code>，他可以不用属于某个类。一眼看上去和 java 差不多。流程控制也是由小括号和大括号构成，不用考虑缩进。<strong>结尾必须要加上分号</strong>。</p><h3 id="声明数据类型"><a href="#声明数据类型" class="headerlink" title="声明数据类型"></a>声明数据类型</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">int</span> l = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">String</span> str1 = <span class="string">&quot;str1&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dynamic</span> d = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> j = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> k = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 是强类型语言，变量都会有一个类型。你可以向 java 那样直接声明类型，同样可以像 swift 或者 Kotlin 那样使用类型推导。Dart 的类型推导使用 final,var,const,dynamic 关键字。</p><ul><li><code>var</code>修饰变量，这个没什么好说的。</li><li><code>final</code>表示不可变的，修饰内置数据类型，值不可变；修饰对象表示引用不可变，使用到的频率很高。</li><li><code>const</code>是编译时常量，他表示始终不可变，无论修饰内置类型还是对象，或者是数据结构。</li><li><code>dynamic</code>是任意类型，有点像 java 里面的<code>Object</code>，Kotlin 中的<code>Any</code>。</li></ul><blockquote><p>使用 const 修饰的都是编译时常量。它区别于运行时，它的值是不可变的。<br><strong>所有的数据类型，不管是 int 还是 String，初始值都是<code>null</code></strong></p></blockquote><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="numbers、strings-和-booleans"><a href="#numbers、strings-和-booleans" class="headerlink" title="numbers、strings 和 booleans"></a>numbers、strings 和 booleans</h4><p>首先是<code>numbers</code>,<code>strings</code>,<code>booleans</code>其中 numbers 包括<code>int</code>和<code>double</code>类型，分别表示整数和浮点数。strings 就是<code>String</code>类型，普通的字符串。booleans 类型是<code>bool</code>只包含<code>true</code>和<code>false</code>。</p><pre><code>numbers* int* doublestrings* Stringbooleans* bool</code></pre><p>如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// numbers</span></span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">double</span> d = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串转数字</span></span><br><span class="line">  <span class="comment">// 这里就使用了类型推导</span></span><br><span class="line">  <span class="keyword">final</span> p1 = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> p2 = <span class="string">&quot;3.3&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">int</span>.parse(p1));</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">double</span>.parse(p2));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// string</span></span><br><span class="line">  <span class="comment">// 可以使用（&#x27;xxx&#x27;）（&quot;xxx&quot;）（&#x27;&#x27;&#x27;xxx&#x27;&#x27;&#x27;） 三种方式初始化字符串，和Kotlin很像。</span></span><br><span class="line">  <span class="comment">// 字符串比较的是值</span></span><br><span class="line">  <span class="keyword">final</span> str1 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> str2 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str1 == str2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> str3 = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> str4 = <span class="string">&#x27;&#x27;&#x27;test&#x27;&#x27;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(str4);</span><br><span class="line">  <span class="built_in">print</span>(str4 == str3); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m <span class="subst">$&#123;str4&#125;</span>!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//booleans</span></span><br><span class="line">  <span class="comment">// null 可以直接用来判断，它是false</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;null is true&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;null is false&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.isEmpty);</span><br><span class="line"><span class="comment">//   final list = [];</span></span><br><span class="line"><span class="comment">//   if(!list) &#123;</span></span><br><span class="line"><span class="comment">//     print(&#x27;not empty&#x27;);</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 的数据结构包括 list 和 map</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>list</code>对应的就是 java 里面的 List，list 可以像 Python 等语言那样使用<code>[]</code>进行数组操作，参照以下示例代码。<br>List 有几个在 flutter 非常常用的初始化方式，分别为<code>filled</code>和<code>generate</code>。具体参考：<a href="https://api.dartlang.org/stable/2.1.0/dart-core/List-class.html">https://api.dartlang.org/stable/2.1.0/dart-core/List-class.html</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">final</span> list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">  <span class="comment">// 编译时常量</span></span><br><span class="line">  <span class="keyword">final</span> list2 = <span class="keyword">const</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="comment">//   list2[2] = 8; error</span></span><br><span class="line">  <span class="built_in">print</span>(list2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化2</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list3 = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">print</span>(list3); <span class="comment">// [null, null, null, null, null]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化3 filled 第一个参数是个数，第二个是添加的值</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list4 = <span class="built_in">List</span>.filled(<span class="number">3</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">print</span>(list4); <span class="comment">// [10,10,10]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化4 类似Python的Map生成</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list5 = <span class="built_in">List</span>.generate(<span class="number">3</span>,(i) =&gt; i * <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(list5); <span class="comment">// [0, 3, 6]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改 使用list1</span></span><br><span class="line">  list1[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">print</span>(list1); <span class="comment">// [1, 2, 8, 4, 5]</span></span><br><span class="line">  <span class="comment">// 添加</span></span><br><span class="line">  list1.add(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//   list1[10] = 20; Index out of range</span></span><br><span class="line">  <span class="built_in">print</span>(list1); <span class="comment">// [1, 2, 8, 4, 5, 10]</span></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  list1.remove(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">print</span>(list1); <span class="comment">// [1, 2, 8, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code> 对应 java 里面的 Map，他的操作方式有点像 Python。需要注意的有几点。</p><ul><li>Map 的 Key 不能有重复的</li><li>如果使用 int 类型作为 key，取值的时候优先使用 key 匹配，然后是下标。</li><li>取不到值不会抛异常，直接返回 null</li><li>Map 和 List 可以转换为 Json,来回转换时深拷贝。</li></ul><p>其他 API 参考：<a href="https://api.dartlang.org/stable/2.1.0/dart-core/Map-class.html">https://api.dartlang.org/stable/2.1.0/dart-core/Map-class.html</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:convert&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"><span class="keyword">final</span> map1 = &#123;</span><br><span class="line">    <span class="string">&quot;test1key&quot;</span> : <span class="string">&quot;test1value&quot;</span>,</span><br><span class="line"><span class="comment">//     &quot;test1key&quot; : &quot;test1value&quot;, Key 不能相同</span></span><br><span class="line">    <span class="number">123</span> : <span class="string">&quot;123value&quot;</span>,</span><br><span class="line">    <span class="keyword">null</span> : <span class="string">&#x27;NULL&#x27;</span>,</span><br><span class="line">    <span class="number">2</span> : <span class="string">&#x27;2&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">print</span>(map1); <span class="comment">// &#123;test1key: test1value, 123: 123value, null: NULL, 2: 2&#125;</span></span><br><span class="line">  <span class="comment">// 获取值</span></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="number">123</span>]); <span class="comment">// key取值 123value</span></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="number">1</span>]); <span class="comment">// 下标取值 null</span></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="number">2</span>]); <span class="comment">// 同时存在时候，优先Key取值；结果为 2</span></span><br><span class="line">  <span class="comment">// 追加值</span></span><br><span class="line">  map1[<span class="string">&#x27;appendKey&#x27;</span>]  = <span class="string">&#x27;appendVal&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(map1);</span><br><span class="line">  <span class="comment">// 更改值</span></span><br><span class="line">  map1[<span class="string">&#x27;appendKey&#x27;</span>]  = <span class="string">&#x27;appendVal123&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(map1);</span><br><span class="line"> map1[<span class="string">&#x27;appendKey&#x27;</span>] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="built_in">print</span>(map1); <span class="comment">// 置为null之后，key不会消失</span></span><br><span class="line">  map1.remove(<span class="string">&#x27;appendKey&#x27;</span>);</span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="built_in">print</span>(map1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(map1[<span class="string">&#x27;non-key&#x27;</span>]); <span class="comment">// 不会报错 打印 null</span></span><br><span class="line">  <span class="built_in">print</span>(map1.length); <span class="comment">// 长度 4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// json 转换</span></span><br><span class="line">  <span class="comment">// 使用const修饰的数据结构，不可改变。</span></span><br><span class="line">  <span class="keyword">final</span> map2 = <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;lecon&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;ss&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">final</span> jsonText = jsonEncode(map2);</span><br><span class="line">  <span class="built_in">print</span>(jsonText); <span class="comment">// &#123;&quot;name&quot;:&quot;lecon&quot;,&quot;age&quot;:23,&quot;ss&quot;:[1,2,3,4,4]&#125;</span></span><br><span class="line">  <span class="keyword">final</span> mapObj = jsonDecode(jsonText);</span><br><span class="line">  <span class="built_in">print</span>(mapObj); <span class="comment">// &#123;name: lecon, age: 23, ss: [1, 2, 3, 4, 4]&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h4><p>这东西其实就是字符集的扩编，可以用它显示一些表情符号</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(clapping);</span><br><span class="line">  <span class="built_in">print</span>(clapping.codeUnits);</span><br><span class="line">  <span class="built_in">print</span>(clapping.runes.toList());</span><br><span class="line"></span><br><span class="line">  Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">      <span class="string">&#x27;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Dart 的函数比 java 多了几个概念。比如在参数列表里面添加个大括号，是<code>可选命名参数</code>；加个中括号叫<code>可选位置参数</code>。</p><ul><li>可选命名参数类似 Python 里面的**kwargs，参考下面示例代码<code>func3</code>；</li><li>可选位置参数类似 Python 里面的*args，参考下面<code>func5</code>。</li><li>可选命名参数和可选位置参数可以有默认值，普通参数不能有，参考<code>func6</code>。</li><li>函数之间可以互相嵌套，互相调用，但他们都有自己作用域。</li><li>若果函数简单可以使用<code>()=&gt; value</code>简写。</li></ul><p>比如</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> test() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写成</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> test ()=&gt; <span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure><p>下面是示例代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#x27;package:meta/meta.dart&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"> func1(<span class="number">123</span>);</span><br><span class="line"> func2(<span class="string">&#x27;222&#x27;</span>);</span><br><span class="line">  func3(<span class="string">&quot;lecon&quot;</span>);</span><br><span class="line"><span class="comment">//   func3(&quot;lecon&quot;,&quot;spawn&quot;,123); error,使用下边的中括号，注意区别。这个使用key区分，下面使用位置区分</span></span><br><span class="line">  func3(<span class="string">&quot;lecon&quot;</span>,param2:<span class="string">&quot;spawn&quot;</span>,param3:<span class="number">123</span>);</span><br><span class="line"><span class="comment">//   func4(&quot;lecon&quot;,param2:&quot;spawn&quot;); error required</span></span><br><span class="line">  func5(<span class="string">&quot;lecon&quot;</span>,<span class="string">&quot;spawn&quot;</span>,<span class="string">&quot;hahaa&quot;</span>);</span><br><span class="line">  func6(<span class="string">&quot;lecon&quot;</span>,age:<span class="number">25</span>);</span><br><span class="line">  <span class="built_in">print</span>(func7());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func1(param1) &#123;</span><br><span class="line">  <span class="built_in">print</span>(param1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> func2(<span class="built_in">String</span> param2) &#123;</span><br><span class="line">  <span class="built_in">print</span>(param2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func3(<span class="built_in">String</span> param1,&#123;<span class="built_in">String</span> param2,<span class="built_in">int</span> param3&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I am <span class="subst">$&#123;param1&#125;</span>, Hi <span class="subst">$&#123;param2&#125;</span>,I am <span class="subst">$&#123;param3&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test in flutter</span></span><br><span class="line"><span class="comment">// void func4(String param1,&#123;String param2,@required int param3&#125;) &#123;</span></span><br><span class="line"><span class="comment">//   print(&quot;I am $&#123;param1&#125;, Hi $&#123;param2&#125;,I am $&#123;param3&#125;&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func5(<span class="built_in">String</span> param1,[<span class="built_in">String</span> param2,<span class="built_in">String</span> param3]) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I am <span class="subst">$&#123;param1&#125;</span>, bian bu <span class="subst">$&#123;param2&#125;</span> xia qu le <span class="subst">$&#123;param3&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有使用&#123;&#125;和[]的才可以有默认值</span></span><br><span class="line"><span class="keyword">void</span> func6(<span class="built_in">String</span> param1,&#123;<span class="built_in">int</span> age = <span class="number">23</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I am <span class="subst">$&#123;param1&#125;</span>, I am <span class="subst">$&#123;age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func7() &#123;</span><br><span class="line">  <span class="keyword">void</span> func8() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> func9() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  retrun () =&gt; <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Dart 的流程控制和 java 的用法基本一样,这里就不介绍了。</p><p>有个 for in 要说下，和 JavaScript 很像。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;&#125;</span><br></pre></td></tr></table></figure><p>相当于 java 的高级 for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : indexs) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>相对于 java 有这几点需要注意</p><ul><li><code>new</code>关键字可以省略</li><li>一个类同名构造器只能有一个，也就是说可以给构造器起其他名字。所以可以把构造器分为<code>默认构造器</code>和<code>命名构造器</code>。</li><li>命名构造器不能自动继承，参考下面</li><li>Dart 使用<code>this</code>代表当前对象</li><li>初始化列表</li><li>Dart 有继承和接口概念，和 java 基本差不多，同时多了个<code>混入</code>的的概念<code>minix</code>，这个非常好理解。</li></ul><p>下面这个例子是类构造器的基本使用</p><h4 id="普通构造器和继承"><a href="#普通构造器和继承" class="headerlink" title="普通构造器和继承"></a>普通构造器和继承</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line">  <span class="built_in">String</span> dantengt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，冒号后边是初始化列表，用，隔开。</span></span><br><span class="line">  Person() :dantengt = <span class="string">&quot;danm&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;name : <span class="subst">$&#123;name&#125;</span>;age : <span class="subst">$&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认构造器只能声明一个</span></span><br><span class="line">  <span class="comment">// 不用写set方法，使用this可以直接把值赋给相应的属性</span></span><br><span class="line">  Person2(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造器</span></span><br><span class="line">  Person2.copy(Person p) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name  = p.name;</span><br><span class="line">    <span class="keyword">this</span>.age = p.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;name : <span class="subst">$&#123;name&#125;</span>;age : <span class="subst">$&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> school;</span><br><span class="line">  <span class="comment">// 普通构造器继承</span></span><br><span class="line">  Student(<span class="built_in">String</span> name,<span class="built_in">int</span> age,<span class="keyword">this</span>.school):<span class="keyword">super</span>(name,age);</span><br><span class="line">  <span class="comment">// 命名构造器的继承</span></span><br><span class="line">  Student.copy(Person p,<span class="keyword">this</span>.school):<span class="keyword">super</span>.copy(p);</span><br><span class="line"><span class="comment">// 类似构造器的重载</span></span><br><span class="line">  Student.mySchoolCopy(Person p):<span class="keyword">this</span>.copy(p,<span class="string">&#x27;mySchool&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有值都不可以改变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"><span class="comment">// cosnt修饰的构造器是常量构造器，里面的值都不许改变。因为是编译时的。</span></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> person = Person();</span><br><span class="line">  person.name = <span class="string">&quot;spawn&quot;</span>;</span><br><span class="line">  person.age = <span class="number">18</span>;</span><br><span class="line">  <span class="built_in">print</span>(person);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> person2 = Person2(<span class="string">&quot;lecon&quot;</span>,<span class="number">25</span>);</span><br><span class="line">  <span class="built_in">print</span>(person2);</span><br><span class="line">  <span class="built_in">print</span>(Person2.copy(person));</span><br><span class="line"></span><br><span class="line">  Person2 p2 = Student(<span class="string">&quot;lecon&quot;</span>,<span class="number">25</span>,<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is 和 as ;类似 instanceof和强转</span></span><br><span class="line">  <span class="keyword">if</span> (p2 <span class="keyword">is</span> Student) &#123;</span><br><span class="line">    (p2 <span class="keyword">as</span> Student).school;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Person 类的构造器后面有个<code>：</code>，那个就是初始化列表，可以给属性赋值（参考 Person 类），还可调用父类构造器。</li><li>Person2 类有两个构造器，默认构造器没有名字，和 java 中一样使用类名声明。另外还有一个<code>Person2.copy()</code> 他也是一个构造器，只不过它有名字了，同名构造器只能出现一次，不管是不是重载（貌似 Dart 没重载）。</li><li>在构造器参数列表中，如果直接使用<code>this</code>关键字，可以直接把值付给类的属性，省去了 set 方法（参考类 Person2 的默认构造器）。</li><li>在类中，所有的属性或者方法，只要带了<code>_</code>前缀，那么他就是私有的，<strong>Dart 文件之外</strong>不能访问，当前文件不同类是可以的。</li><li><code>is</code>关键字相当于<code>instanceof</code> ，<code>as</code>相当于强转。这个和 Kotlin 很像。</li><li><code>const</code>修饰构造器，代表类是编译时的。所有内容不允许改变。</li><li>类的继承使用<code>extends</code>关键字，同时 dart 也有<code>接口</code>，和 java 基本一致，不再赘述。</li><li>除了继承和接口之外，Dart 还有个<code>mixin</code>混入的概念，可以把他理解为：把其他类的东西，一股脑放到当前类中，使用<code>with</code>关键字描述。</li></ul><h4 id="minix"><a href="#minix" class="headerlink" title="minix"></a>minix</h4><p>关于 minix 参考以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class关键字换成minix，其他和class一样，只是换个名字。</span></span><br><span class="line"><span class="keyword">mixin</span> Play &#123;</span><br><span class="line">  <span class="keyword">void</span> play() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can play&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Eat &#123;</span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I can eat&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with关键字加入mixin类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">Play</span>,<span class="title">Eat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> age;</span><br><span class="line">  Person(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> p = Person(<span class="string">&quot;lecon&quot;</span>,<span class="number">13</span>);</span><br><span class="line">  <span class="comment">// 此时p有了Eat和Play的能力</span></span><br><span class="line">  p.play();</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="factory-构造器和多态"><a href="#factory-构造器和多态" class="headerlink" title="factory 构造器和多态"></a>factory 构造器和多态</h4><p>java 编程中，在使用多态的时候，我们可能会用到工厂方法，dart 给我们提供一个方便，使用 dart 的工厂构造器。dart 的工厂构造器也是个构造器，只不过使用 factory 修饰，他返回当前类，并且不能使用 this 关键字，示例代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  Person2(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// factory 构造器也是构造器，同样不能声明两个相同名字的，而且只能有一个默认</span></span><br><span class="line">  <span class="comment">// factory 没有this引用</span></span><br><span class="line">  <span class="keyword">factory</span> Person2.select(name,<span class="built_in">int</span> age,<span class="built_in">int</span> type) &#123;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Student(name,age,<span class="string">&quot;jaja&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Worker(name,age,<span class="string">&quot;lala&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// callable</span></span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">&#x27;<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;name : <span class="subst">$&#123;name&#125;</span>;age : <span class="subst">$&#123;age&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> school;</span><br><span class="line"></span><br><span class="line">  Student(<span class="built_in">String</span> name,<span class="built_in">int</span> age,<span class="keyword">this</span>.school):<span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> company;</span><br><span class="line"></span><br><span class="line">  Worker(<span class="built_in">String</span> name,<span class="built_in">int</span> age,<span class="keyword">this</span>.company):<span class="keyword">super</span>(name,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"><span class="comment">// 不关注Person2实现类，直接使用Person2实例化。使用factory</span></span><br><span class="line">  <span class="keyword">final</span> p1 = Person2.select(<span class="string">&quot;lecon&quot;</span>,<span class="number">23</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">final</span> p2 = Person2.select(<span class="string">&quot;lecon&quot;</span>,<span class="number">23</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(p1.runtimeType); <span class="comment">// Student</span></span><br><span class="line">  <span class="built_in">print</span>(p2.runtimeType); <span class="comment">// Worker</span></span><br><span class="line">  <span class="comment">// callable</span></span><br><span class="line">  <span class="built_in">print</span>(p1(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;234&quot;</span>,<span class="string">&quot;345&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>select</code>为 Person2 的工厂构造器，由它来返回对应的实现类。</p><h4 id="setter-和-getter"><a href="#setter-和-getter" class="headerlink" title="setter 和 getter"></a>setter 和 getter</h4><p>很多语言里面，为了方便获取属性都提供了 setter 和 getter。其实他就是个语法糖。直接使用就可以。看例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Dart 的异常也和 java 非常像。直接看例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"><span class="comment">//    throw1();</span></span><br><span class="line"><span class="comment">//    throw2();</span></span><br><span class="line"><span class="comment">//    throw3();</span></span><br><span class="line"><span class="comment">//    throw4();</span></span><br><span class="line">      throw5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw1() &#123;</span><br><span class="line">  <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw2() &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Expected at least 1 section&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw3() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;section exception <span class="subst">$&#123;e&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException <span class="keyword">catch</span>(e,s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception <span class="subst">$&#123;e&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="built_in">print</span>(s); <span class="comment">// 打印方法调用栈</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw4() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception&#x27;</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// 重抛</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> throw5() &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">on</span> FormatException &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;section exception&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;I am finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dart 可以直接抛出默认异常，<code>throw &#39;Expected at least 1 section&#39;;</code></li><li>使用<code>on</code>来匹配异常类型，<code>on FormatException</code></li><li>使用<code>catch</code>来获取异常变量，<code>catch(e,s)</code>它有一个默认参数和可选参数。分别为信息和调用栈。</li><li>使用<code>rethrow</code>重新抛出异常</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>dart 的异步和 JavaScript ES6 差不多，使用<code>await</code>和<code>async</code>，只不过 ES6 中的 Promise 变成了 Future。目前比较流行的解决方案都是这个，比如 Python,Kotlin 都这么使用。一般在网络请求或者数据库操作时候使用，就像 java 的多线程基础版吧。</p><p>异步这块东西有点多，而且很重要，直接贴官方地址。<a href="https://www.dartlang.org/guides/libraries/library-tour#future">https://www.dartlang.org/guides/libraries/library-tour#future</a></p><p>异步中有两个很重要的接口：<code>Future</code>和<code>Stream</code>。贴出地址，这两个一定要弄明白。<a href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming">https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming</a></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>Dart 的生成成器和其他语言里面的生成器差不多，分为<code>同步</code>和<code>异步</code>两种。同步生成器结构是<code>Iterable</code>，异步生成器接口是<code>Stream</code>。流程控住使用<code>async*</code>（异步）和<code>sync*</code>（同步）声明，使用<code>yield</code>流程控制，每一次<code>yield</code>都会给列表生成一个值，也就是说生成器返回结果的数据结构可以当列表使用。以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(naturalsTo(<span class="number">10</span>)); <span class="comment">// (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line">  <span class="built_in">print</span>(naturalsDownFrom(<span class="number">10</span>)); <span class="comment">// (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span></span><br><span class="line">  asynchronousNaturalsTo(<span class="number">10</span>)</span><br><span class="line">    .toList() <span class="comment">// toList把异步转为同步</span></span><br><span class="line">    .then((res) &#123;</span><br><span class="line">      <span class="built_in">print</span>(res); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsTo(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步生成器</span></span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归性质的生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅导入foo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排除foo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:greetings/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure><h4 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h4><p>Dart 也有<code>null</code>类型，并且和其他语言类似，Dart 也是用<code>？</code>来解决空问题。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> a = <span class="keyword">null</span>;</span><br><span class="line">  <span class="built_in">print</span>(a != <span class="keyword">null</span> ? a : <span class="string">&quot;b&quot;</span>); <span class="comment">// 等同于下边,dart也支持三元运算符</span></span><br><span class="line">  <span class="built_in">print</span>(a ?? <span class="string">&quot;b&quot;</span>); <span class="comment">// 打印 b</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> p = <span class="keyword">null</span>;</span><br><span class="line">  <span class="built_in">print</span>(p?.toString()); <span class="comment">//打印null，而不会空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="..运算符"></a><code>..</code>运算符</h4><p>Dart 的联级运算符<code>..</code>很有意思，很实用的语法糖，直接看代码你就明白了。<code>Builder</code>大法好。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">   <span class="comment">// 联级运算符</span></span><br><span class="line"><span class="keyword">final</span> p = Person()</span><br><span class="line">  ..username = <span class="string">&quot;lecon&quot;</span></span><br><span class="line">    ..password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    ..setSex(<span class="keyword">true</span>);</span><br><span class="line">  <span class="built_in">print</span>(p); <span class="comment">// Username: lecon; Password: 123456; Sex: true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _username;</span><br><span class="line">  <span class="built_in">String</span> _password;</span><br><span class="line">  <span class="built_in">bool</span> _sex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> username(<span class="built_in">String</span> username)  =&gt; <span class="keyword">this</span>._username = username;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> password(<span class="built_in">String</span> password)  =&gt; <span class="keyword">this</span>._password = password;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setSex(<span class="built_in">bool</span> sex)  =&gt; <span class="keyword">this</span>._sex = sex;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;Username: <span class="subst">$&#123;<span class="keyword">this</span>._username&#125;</span>; Password: <span class="subst">$&#123;<span class="keyword">this</span>._password&#125;</span>; Sex: <span class="subst">$&#123;<span class="keyword">this</span>._sex&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h4><p>这个和 C++里边的内联函数基本差不多。<br>官方例子 <a href="https://www.dartlang.org/guides/language/language-tour#typedefs">https://www.dartlang.org/guides/language/language-tour#typedefs</a></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>Dart 注释分为三种，单行注释和多行注释和 java 一致。doc 注释使用 <code>///</code>表示。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A domesticated South American camelid (Lama glama).</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Andean cultures have used llamas as meat and pack</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">animals since pre-Hispanic times.</span></span></span><br></pre></td></tr></table></figure><p>##最后<br>临时总结，难免有错误，请多多指出，我会在第一时间改正。</p><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://gist.github.com/leconio/73bd75eef9530ff76ac59e09b1331865">https://gist.github.com/leconio/73bd75eef9530ff76ac59e09b1331865</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先本文是通过对比其他语言（主要是 java）快速入门&lt;/p&gt;
    
    </summary>
    
    
      <category term="玩儿" scheme="https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Shadowsocks 实战教程全景实录（2）</title>
    <link href="https://lecon.io/2019/06/10/Shadowsocks%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%E5%85%A8%E6%99%AF%E5%AE%9E%E5%BD%95%EF%BC%882%EF%BC%89/"/>
    <id>https://lecon.io/2019/06/10/Shadowsocks%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%E5%85%A8%E6%99%AF%E5%AE%9E%E5%BD%95%EF%BC%882%EF%BC%89/</id>
    <published>2019-06-10T13:13:09.000Z</published>
    <updated>2021-03-03T13:01:04.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这次的教程主要分为以下几个部分：</p></blockquote><ol><li>搭建 Shadowsocks-libev 服务端</li><li>配置防火墙</li></ol><span id="more"></span><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2019/06/17/trrr.png" alt=""></p><p>接着上回说，现在我们 ssh 到搬瓦工服务器。</p><h2 id="检查-bbr"><a href="#检查-bbr" class="headerlink" title="检查 bbr"></a>检查 bbr</h2><p>第一件事儿就是检查有没有开启 bbr 内核，bbr 对于 VPS 的提速上一节已经说过了，非常大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>如果显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno</span><br></pre></td></tr></table></figure><p>代表 bbr 已经开启。如果结果中没有 bbr 也不用担心，我在上一篇文章放出了一个安装 bbr 和锐速的脚本，可以直接使用。</p><h2 id="安装-Shadowsocks-服务器"><a href="#安装-Shadowsocks-服务器" class="headerlink" title="安装 Shadowsocks 服务器"></a>安装 Shadowsocks 服务器</h2><p>前段时间秋大的博客宣布告别，这意味着高质量的一键安装脚本越来越少。虽然搬瓦工提供一件安装选项，但可定制化不高，所以我建议大家使用托管在 github 的原始项目，理由是可以保持功能最新，遇到问题也可以通过 issues 而得到迅速解决，<a href="https://github.com/shadowsocks/shadowsocks-libev">shadowsocks-libev</a>。<br><strong>首先安装依赖项目</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y</span><br></pre></td></tr></table></figure><p><code>shadowsocks-libev</code> 托管在 dnf 的 copr 仓库内，默认的 centos7 是不带这个仓库。这里我们安装 dnf 和 copr 仓库。<br><strong>1. 安装 dnf 和 copr 仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install dnf</span><br><span class="line">dnf install dnf-plugins-core</span><br><span class="line">dnf install dnf-plugins-copr</span><br></pre></td></tr></table></figure><p><strong>2. 开启 copr 的<code>shadowsocks-libev</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf copr enable librehat&#x2F;shadowsocks</span><br></pre></td></tr></table></figure><p><strong>3. 安装 <code>shadowsocks-libev</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf update</span><br><span class="line">dnf install shadowsocks-libev</span><br></pre></td></tr></table></figure><p>到此为止，如果没有出现什么问题，安装就算完成了，现在执行下面的命令来测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-server -h</span><br></pre></td></tr></table></figure><h2 id="配置服务端参数"><a href="#配置服务端参数" class="headerlink" title="配置服务端参数"></a>配置服务端参数</h2><p>上面说到，通过执行 ss-server 可以启动一个 ss 服务器，但是，在实际使用的时候，我们通常设置自己使用的参数，下面的例子是一组最简单的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-server -p 8989 -k 123456 -m chacha20 --fast-open</span><br></pre></td></tr></table></figure><p>其中-p 是对外开放的端口，-k 是密码，-m 是加密方式，chacha20 是一种非常优秀的加密方式呦，你懂得。–fast-open 开启 TCP 快速打开模式。<br>你可以直接在 VPS 的执行上面的命令，但是这是一个阻塞命令，我们可以使用 nohup 来切换到后台运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ss-server -p 8989 -k 123456 -m chacha20 --fast-open &amp;</span><br></pre></td></tr></table></figure><p><strong>看一下我们的 ss-server 是否启动成功</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过pid查看ss是否启动</span><br><span class="line">ps -ef|grep ss-server</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过端口查看ss是否启动</span><br><span class="line">iptables -xvn -L|grep 8989</span><br></pre></td></tr></table></figure><p><strong>别忘了防火墙</strong><br>在上面的参数中，ss 对外开放的端口是 8989。那么我们通过 Centos7 的 firewalld-cmd 防火墙放行这个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br><span class="line">firewall-cmd --set-default-zone&#x3D;public</span><br><span class="line">firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;ssh</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;tcp</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;udp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>上面开启了 ssh 服务使用的端口和 8989 端口，如果你还有需要使用的端口，请参考这篇文章<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">How To Set Up a Firewall Using FirewallD on CentOS 7</a><br>好啦！测试一下我们的 8989 通不通吧，在本地电脑 telnet 到 8989</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [domain name or ip] 8989</span><br></pre></td></tr></table></figure><p>空白代表通了。</p><p>（未完待续）<br>下一篇讲述怎么搭建客户端，以及一些小技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这次的教程主要分为以下几个部分：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;搭建 Shadowsocks-libev 服务端&lt;/li&gt;
&lt;li&gt;配置防火墙&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="玩儿" scheme="https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Shadowsocks 实战教程全景实录（1）</title>
    <link href="https://lecon.io/2019/06/08/Shadowsocks%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%E5%85%A8%E6%99%AF%E5%AE%9E%E5%BD%95%EF%BC%881%EF%BC%89/"/>
    <id>https://lecon.io/2019/06/08/Shadowsocks%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%E5%85%A8%E6%99%AF%E5%AE%9E%E5%BD%95%EF%BC%881%EF%BC%89/</id>
    <published>2019-06-08T12:36:46.000Z</published>
    <updated>2021-03-03T13:01:04.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近些日子，很多同事都在说自己的代理又不能用了。有的被封 IP，有的 DNS 污染。万里长城在中美贸易战的的大情况下越来越坚固。秋大论坛也宣布告别，搬瓦工取消 29.9 美金的最低套餐，真是苦了我们这些普通程序员了，我们只想安安静静的学习一下国外程序员的经验。</p></blockquote><span id="more"></span><p>首先这篇文章的定位是交给大家，怎么使用自己的 VPS 搭建 Shadowsock 服务器，网上的教程有很多，我自己也探了不少的坑，那么，就说下一我自己的经验。</p><h2 id="VPS-提供商"><a href="#VPS-提供商" class="headerlink" title="VPS 提供商"></a>VPS 提供商</h2><p>我的 VPS 选购的是搬瓦工，由于购买的比较早，每年只需 19.9 美金。现在最低是 49.9 美金，以我对搬瓦工这个尿性的了解，基本不会再恢复 29.9 的价位了。相比其他 VPS 提供商，每年 50 刀的价格也算比较良心的。而且这家提供商的机器真的是稳得一笔呀，很少有丢包的情况，基本日常工作可以满足。测速也可以把带宽跑到慢速，我家是 100Mb 宽带，下载速度在 10+MB/S 左右。</p><blockquote><p>如果你跟着我的主线流程慢慢做，那么你也可以到达这个速度。</p></blockquote><p>如果你和我一样，选择搬瓦工的话，那么在选择机房的时候，要选择 CN2 线路。到中国的延迟只有 160ms 左右（深圳），操作系统选择 Centos7。<br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2019/06/08/15599964405169.jpg" alt="-w690"></p><blockquote><p>注意，CN2 的线路只有 0.33x 的流量。比如说，如果你的机器是 500GB 每月，那么流量就变成 0.33 的倍数。</p></blockquote><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2019/06/08/15599965477559.jpg" alt="-w520"></p><p>操作系统选择 Centos7，其他的系统我也都用过，但是这个是最稳定的，Centos6 也可以，但是软件都比较老，防火墙只能用 iptables。debian 和 ubuntu 在网路持续最大化的时候，可能会将 ss-server 进程杀死。</p><p><strong>关于 bbr</strong><br>我推荐使用 bbr，关于是不是用，我说一个数据你就明白了。在没有使用 bbr 之前，我下载速度最多只有 40kb/s，使用字后可以到 300kb/s。当然，你也可以选择锐速，或者暴力魔改 bbr，我贴出一个切换 bbr 和锐速的链接，大家自己选择。若这里选择了 bbr，并且你也不愿意折腾，那么就不用关注这个链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chiakge&#x2F;Linux-NetSpeed&#x2F;master&#x2F;tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; .&#x2F;tcp.sh</span><br></pre></td></tr></table></figure><p>安装好系统之后，通过 ssh 接入机器。</p><p>（未完待续）<br>下一篇讲述怎么搭建 Shadowsocks-libev 服务器，搭建完成之后，就可以使用 SS 的基本功能了！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;近些日子，很多同事都在说自己的代理又不能用了。有的被封 IP，有的 DNS 污染。万里长城在中美贸易战的的大情况下越来越坚固。秋大论坛也宣布告别，搬瓦工取消 29.9 美金的最低套餐，真是苦了我们这些普通程序员了，我们只想安安静静的学习一下国外程序员的经验。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="玩儿" scheme="https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>破解公司 Mac 电脑的 jamf 限制，让 Mac 可以共享 Wifi</title>
    <link href="https://lecon.io/2019/06/05/%E7%A0%B4%E8%A7%A3%E5%85%AC%E5%8F%B8Mac%E7%9A%84Wifi%E5%85%B1%E4%BA%AB%E9%99%90%E5%88%B6/"/>
    <id>https://lecon.io/2019/06/05/%E7%A0%B4%E8%A7%A3%E5%85%AC%E5%8F%B8Mac%E7%9A%84Wifi%E5%85%B1%E4%BA%AB%E9%99%90%E5%88%B6/</id>
    <published>2019-06-05T08:49:06.000Z</published>
    <updated>2021-03-03T13:01:04.533Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。</p><span id="more"></span><p><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2019/06/05/20190605161019.png" alt="20190605161019"><br><img src="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/2019/06/05/20190605161023.png" alt="20190605161023"></p><p>这些功能的限制都是通过 Mac 的 jamf 管理的，破解限制需要 Root 权限。<br>首先我们先找到 jamf 这个可执行文件，他一般在 <code>/usr/local/jamf/</code> 下面。也可以通过 find 命令查找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find /usr/<span class="built_in">local</span> |grep jamf</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/jamf</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/jamfAgent</span><br><span class="line">/usr/<span class="built_in">local</span>/jamf</span><br><span class="line">/usr/<span class="built_in">local</span>/jamf/bin</span><br><span class="line">/usr/<span class="built_in">local</span>/jamf/bin/jamf</span><br></pre></td></tr></table></figure><p>我的 jamf 可执行文件在 <code>/usr/local/jamf/bin</code> 下面。那么开始破解：</p><p>首先通过执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo jamf removeMDMProfile</span><br></pre></td></tr></table></figure><p>移除 jamf 的限制，这时候受限制的功能就可以使用了。但是，过一段时间之后你会发现又恢复原来的状态了。那么应该怎么解决呢？<br>我们做一个伪装的 jamf 吧！这时候系统调用 <code>jamf</code> 的时候，就会调用我们伪装的文件，不让我们的破解失效。</p><ol><li>首先备份原始文件，这里要把整个 bin 目录备份。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/jamf</span><br><span class="line">mkdir backup</span><br><span class="line">mv bin backup</span><br></pre></td></tr></table></figure><ol start="2"><li>新建一个伪装 jamf 的纯文本文档，输入以下信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo &#39;dummy&#39; &gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><ol start="3"><li>替换原有的 jamf</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;</span><br><span class="line">sudo mv jamf &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;</span><br><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;jamf</span><br></pre></td></tr></table></figure><p>然后重启你的 Mac ，大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="玩儿" scheme="https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Godaddy 快速配置三级域名</title>
    <link href="https://lecon.io/2019/03/08/%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%89%E7%BA%A7%E5%9F%9F%E5%90%8D/"/>
    <id>https://lecon.io/2019/03/08/%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%89%E7%BA%A7%E5%9F%9F%E5%90%8D/</id>
    <published>2019-03-08T01:08:49.000Z</published>
    <updated>2021-03-03T13:01:04.533Z</updated>
    
    <content type="html"><![CDATA[<p>如何配置快速配置三级域名</p><span id="more"></span><p>一般我们使用 A 记录添加二级域名，如下图：</p><p>![](<a href="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/屏幕快照">https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/屏幕快照</a> 2019-03-08 09.14.11.png)</p><p>这条记录吧<code>f.xxx.xxx</code>解析到局域网<code>10.118.60.71</code>。</p><p><strong>添加三级域名需要再加上一条 C 记录</strong>。如下图</p><p>![](<a href="https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/屏幕快照">https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/屏幕快照</a> 2019-03-08 09.14.29.png)</p><p>这条记录吧<code>xxx.f.xxx.xxx</code>解析到上面的<code>f.xxx.xxx</code>地址，也就是<code>10.118.60.71</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何配置快速配置三级域名&lt;/p&gt;
    
    </summary>
    
    
      <category term="玩儿" scheme="https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos7增加swap分区大小</title>
    <link href="https://lecon.io/2018/12/21/Centos7%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
    <id>https://lecon.io/2018/12/21/Centos7%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</id>
    <published>2018-12-21T05:57:17.000Z</published>
    <updated>2021-03-03T13:01:04.533Z</updated>
    
    <content type="html"><![CDATA[<p>如何增加 Centos7 的 swap 分区大小</p><span id="more"></span><p>1.添加 swap 分区<br>dd if=/dev/zero of=/var/swapfile bs=1024 count=4096k</p><p>2.执行完毕，对交换文件格式化并转换为 swap 分区：<br>mkswap /var/swapfile</p><p>3.挂载并激活分区：<br>swapon /var/swapfile</p><p>4 赋权限<br>chmod -R 0600 /var/swapfile</p><p>5.设置开机自动挂载该分区：<br>vi /etc/fstab<br>在 fstab 文件末尾追加如下内容后:wq!保存即可：<br>/var/swapfile swap swap defaults 0 0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何增加 Centos7 的 swap 分区大小&lt;/p&gt;
    
    </summary>
    
    
      <category term="黑洞" scheme="https://lecon.io/categories/%E9%BB%91%E6%B4%9E/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Caddy代理Bitbucket服务器</title>
    <link href="https://lecon.io/2018/12/21/%E4%BD%BF%E7%94%A8Caddy%E4%BB%A3%E7%90%86Bitbucket%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://lecon.io/2018/12/21/%E4%BD%BF%E7%94%A8Caddy%E4%BB%A3%E7%90%86Bitbucket%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2018-12-21T05:55:53.000Z</published>
    <updated>2021-03-03T13:01:04.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。</p></blockquote><span id="more"></span><h2 id="Bitbucket"><a href="#Bitbucket" class="headerlink" title="Bitbucket"></a>Bitbucket</h2><p>Bitbucket 虽然不是一个免费的版本管理工具，但是本身体验还是很好的，即使付费版本个人使用也很便宜。基于 Java 实现，执行效率当然说的过去。相比于 gitlab 这种需要内存至少 2G 的怪兽，至少是一个选择，而却他不容易宕机，但是他的最大魅力还是配置比较简单。</p><h5 id="下载方式，官网找下载链接，直接-wget"><a href="#下载方式，官网找下载链接，直接-wget" class="headerlink" title="下载方式，官网找下载链接，直接 wget"></a>下载方式，官网找下载链接，直接 wget</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;bitbucket.org&#x2F;product&#x2F;download</span><br></pre></td></tr></table></figure><h2 id="Caddy"><a href="#Caddy" class="headerlink" title="Caddy"></a>Caddy</h2><p>使用 Caddy 之前，一直使用 Nginx 作为反向代理服务器，但是 Nginx 配置比较复杂，本身又基于服务模式启动，对于玩家不太友好。Caddy 解决了这些问题，下载好，只需要要执行一个命令就可以启动服务器，全世界都能看到你了。主要是，他可以自动申请 ssl，免去自己申请。</p><h5 id="下载方式："><a href="#下载方式：" class="headerlink" title="下载方式："></a>下载方式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;getcaddy.com | bash -s personal</span><br></pre></td></tr></table></figure><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>Atlassian 家的软件启动都非常简单。下载好之后，给它一个可执行的权限，然后<code>./</code>他就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x atlassian-bitbucket-5.16.0-x64.bin</span><br><span class="line">.&#x2F;atlassian-bitbucket-5.16.0-x64.bin</span><br></pre></td></tr></table></figure><p>这个步骤最好给它 Root 权限。<br>安装完成之后，在<code>/opt</code>下面你可以找到他。到<code>bin</code>目录下，启动它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;atlassian&#x2F;bitbucket&#x2F;5.16.0&#x2F;bin</span><br><span class="line">.&#x2F;start-bitbucket.sh</span><br></pre></td></tr></table></figure><p>然后，访问<code>youip:7990</code>。现在大概可以配置这台 git 服务器了。<br>一台电脑只有一个 80 或者 443 端口，不同的服务想使用同一个端口就需要反向代理服务器了。<br>Caddy 需要一个 Caddyfile 文件，可以理解为 Caddy 的描述文件，随便创建一个目录，然后新建这个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~&#x2F;www</span><br><span class="line">cd ~&#x2F;www</span><br><span class="line">vi Caddyfile</span><br></pre></td></tr></table></figure><p>在这个文件中粘贴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git.lecon.io &#123;</span><br><span class="line">    proxy &#x2F; http:&#x2F;&#x2F;127.0.0.1:7990 &#123;</span><br><span class="line">        header_upstream Host &#123;host&#125;</span><br><span class="line">        header_upstream X-Real-IP &#123;remote&#125;</span><br><span class="line">        header_upstream X-Forwarded-For &#123;remote&#125;</span><br><span class="line">        header_upstream X-Forwarded-Server &#123;host&#125;</span><br><span class="line">        header_upstream X-Forwarded-Proto &#123;scheme&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思大概就是说，把客户端的环境信息原封不动的发送给被代理对象。<br>在当前 Caddyfile 目录中执行<code>caddy</code>。输入一下邮箱，现在访问你的网址，可以直接使用了。这个命令会阻塞当前 session，所以最好叫他到后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup caddy &amp;</span><br></pre></td></tr></table></figure><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>Caddy 会默认把 http 流量转发到 https 上，给客户端发送一个 302，重定向到 https 网址，这样的话就会出现一个问题，我在打开 Bitbucket 网页，然后请求外部网页，就会发生跨域问题，导致 Webhook 功能不能使用。<br>现在需要配置一下 Bitbucket，找到<code>bitbucket.properties</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;|grep bitbucket.properties</span><br></pre></td></tr></table></figure><p>然后加入下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;7990</span><br><span class="line">server.secure&#x3D;true</span><br><span class="line">server.scheme&#x3D;https</span><br><span class="line">server.proxy-port&#x3D;443</span><br><span class="line">server.proxy-name&#x3D;git.lecon.io</span><br></pre></td></tr></table></figure><p>重启一下 Bitbucket 服务器，Webhook 等功能可以正常使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="玩儿" scheme="https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"/>
    
    
  </entry>
  
</feed>
