{"meta":{"title":"lecon","subtitle":null,"description":null,"author":"lecon","url":"https://leconio.github.io","root":"/"},"pages":[],"posts":[{"title":"Gradle依赖中关于Maven和源码依赖的一个问题","slug":"Gradle依赖中关于Maven和源码依赖的一个问题","date":"2021-03-04T10:07:21.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/04/Gradle依赖中关于Maven和源码依赖的一个问题/","link":"","permalink":"https://leconio.github.io/2021/03/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%AD%E5%85%B3%E4%BA%8EMaven%E5%92%8C%E6%BA%90%E7%A0%81%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/","excerpt":"不同的依赖方式可以组合使用，但他们组合使用时候坑确实很多","text":"不同的依赖方式可以组合使用，但他们组合使用时候坑确实很多 Java 的常用的依赖方式通常有三种，即 Maven，jar（aar）包，和源码依赖，不同的依赖方式可以组合使用，但他们组合使用时候坑确实很多，下面我们就讨论集中比较常见的情况，这也是我们开发者在进行多模块开发时候会遇到的问题。 在进行多模块开发过程中，我们通常把经常需要变动的业务模块使用源码依赖的方式进行依赖，如下所示： 12api project(&quot;:mavenlibrary2&quot;)implementation project(&quot;:mavenlibrary2&quot;) 而公共库以及很少变动的模块，通常使用 Maven 方式进行依赖，如下所示： 1implementation &#x27;io.lecon.app:depdemo:1.0.0&#x27; 想法是非常好的，但是实际开发过程中，随着代码量的增大就显得不是那么回事儿了。业务模块还好说，都是源码依赖方式，基本上不会出现什么问题。但是在使用 Maven 进行依赖的公共库模块就发生了问题。下面看一种情况： 业务模块正常依赖这个不用管，但是公共模块中同样很多模块进行开发。这时候我们业务模块使用 Maven 的方式对公共模块进行依赖，那么公共模块的各个子模块之间的依赖方式是什么呢？Maven，源码？这样说你可能不好理解，如下图所示:先说答案，只能使用 Maven 的方式依赖Maven 在进行打包的时候，不会将源码依赖的子功能打包进去，但是会保存依赖信息。如果你确实这么做了的话，也许会遇到这样的错误： 1ERROR: Failed to resolve: AppLibrary:mavenlibrary2:unspecified 在进行公共模块开发时候，可以使用源码的方式进行依赖，但是最后放到业务里面运行的时候，公共模块的所有子模块之间一定要全部使用 Maven 方式进行依赖。 但是这样就会出现一个问题，不同的模块版本号之间如何保持一致？其实这是一个很严重的问题，不同版本之间开放的 api 很有可能不一样，而这些问题在编译时候不一定会报出来，也就是说在运行时会发生类找不到的问题。所以在要把所有 Maven 依赖的项目的版本号以及依赖顺序要统一管理起来，这个话题下次再说。","categories":[{"name":"Android","slug":"Android","permalink":"https://leconio.github.io/categories/Android/"}],"tags":[]},{"title":"一步一步使用Android调用Golang","slug":"一步一步使用Android调用Golang","date":"2021-03-04T10:05:09.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/04/一步一步使用Android调用Golang/","link":"","permalink":"https://leconio.github.io/2021/03/04/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8Android%E8%B0%83%E7%94%A8Golang/","excerpt":"","text":"前提需要了解的 在 Android 中运行 go 代码，需要用到一个工具gomobile，后面会说到安装方式。 Go 开发环境，配置好 GOPATH 和 GOROOT 等。 AndroidSDK 和 AndroidNDK 准备好 Go 代码首先要准备好 GO 的开发坏境，并且配置好 GOPATH，咱们的项目叫mobilego 1234mkdir code/mobilegocd code/mobilegoecho export GOPATH=\\$GOPATH:$(pwd) &gt;&gt; ~/.zshrc # .zshrc 为你的bash地址source ~/.zshrc 其中code/mobilego是咱们 go 项目地址。那么现在就可以准备 go 代码了，那么我们可以按照这个样子新建一个项目。 1234mobilego└── src └── mobile └── mobile.go 其中，src 目录是必须要有的，因为 gomobile 需要从这个路径下查找包。其中mobile.go代码为： 1234567891011121314151617181920package mobileimport &quot;fmt&quot;func SayHello() &#123; fmt.Println(&quot;Hello Mobile&quot;)&#125;func SayHelloWithParams(name string) &#123; fmt.Println(&quot;Hello&quot;, name)&#125;func SayHelloWithParamsAndReturn(name string) string &#123; return &quot;Hello&quot; + name&#125;func SayHelloWithParamsAndReturnAndException(name string) (string,error) &#123; return &quot;Hello&quot; + name, fmt.Errorf(&quot;some error&quot;)&#125; 这个mobile.go就是 java 和 go 文件通信的入口，其中 gomobile 会把这个文件的包名，编译成 java 对应符合 java 命名规范的类名（Mobile）。 mobile.go通过四个例子来演示 java 和 go 的通信。其中第一个无参数无返回值；第二个有参数无返回值；第三个有参数有返回值（同步返回）；第四个有参数有返回值并且抛出一个异常。由于 java 不支持多返回值，如果 go 使用多个返回值的话，会报出错误。 准备 gomobilegomobile 是一个可以为 go 编译成 android 和 ios 平台使用的工具，他的使用说明在https://github.com/golang/go/wiki/Mobile#tools可以找到。 首先下载这个工具 1go get golang.org&#x2F;x&#x2F;mobile&#x2F;cmd&#x2F;gomobile golang.org 的代码基本上都托管在 google 服务器，一般来说在国内都不会下载成功的。那么只好换成另外一种下载方式。在这里，我们把 golang.org/x/mobile/cmd/gomobile中的golang.org/x/换成github.com/golang/。如下所示： 1go get github.com&#x2F;golang&#x2F;mobile&#x2F;cmd&#x2F;gomobile 这时候你会发现，这个包下载到了 GOPATH/github.com 下面了。我们要把它拷贝到 golang.org 目录下面 1mv $GOPATH&#x2F;src&#x2F;github.com&#x2F;golang&#x2F;mobile $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;mobile 然后重新执行： 1go get golang.org&#x2F;x&#x2F;mobile&#x2F;cmd&#x2F;gomobile 不出意外，gomobile 已经安装完成了。执行gomobile version检查一下是否安装成功。 编译 go 代码这一步要把 go 代码编译成 Android 平台使用的机器码。gomobile 是一个非常好用的工具，通过一个命令不仅能把 go 代码编译成平台码，同时还会使用 aar 包来包装它，也就是说，我们完全不用写恶心的 native 代码了，直接调用 gomobile 生成的 Java 代码就好了。 首先来到 go 项目目录下面，执行 gomobile 编译命令。gomobile 需要 NDK，再次确定一下是否安装 NDK。 1gomobile bind -target&#x3D;android mobile.go mobile.go为入口文件。如果没什么问题的话，在项目目录下面就会多出两个文件。mobile.aar和mobile-sources.jar。其中mobile.aar就是我们编译完成的文件。 Android 调用 Go把上面的生成的mobile.aar拷贝到 Android 项目中的 lib 下面，同时修改build.gradle，在 dependencies 中加入或者修改一下代码， 默认值： 1implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) 修改后： 1implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;,&#39;*.aar&#39;]) Sync 一下工程，通过 Java 测试一下我们的 go 代码。 123456789101112131415internal class RunTask : AsyncTask&lt;Void, Void, Any?&gt;() &#123; override fun doInBackground(vararg params: Void): Any? &#123; Mobile.sayHello() Mobile.sayHelloWithParams(&quot;lecon&quot;) val result = Mobile.sayHelloWithParamsAndReturn(&quot;spawn&quot;) Log.d(&quot;AndroidGo&quot;,result) try &#123; Mobile.sayHelloWithParamsAndReturnAndException(&quot;liucl&quot;) &#125; catch (e:Exception) &#123; e.printStackTrace() &#125; return null &#125;&#125; 运行结果: 12342019-04-18 13:31:04.566 7925-7982&#x2F;? D&#x2F;AndroidGo: Hellospawn2019-04-18 13:31:04.571 7925-7982&#x2F;? W&#x2F;System.err: at mobile.Mobile.sayHelloWithParamsAndReturnAndException(Native Method)2019-04-18 13:31:04.590 7925-7987&#x2F;? I&#x2F;GoLog: Hello Mobile2019-04-18 13:31:04.590 7925-7987&#x2F;? I&#x2F;GoLog: Hello lecon 这时候，你也许会发现，这几行代码的执行顺序是不确定的。因为 java 和 go 通信是跨进程调用，这几个方法有几个 log 是在 go 中输出，就不能保证执行顺序。 项目代码放到 github 上：https://github.com/leconio/AndroidCallGoDemo","categories":[{"name":"Go","slug":"Go","permalink":"https://leconio.github.io/categories/Go/"}],"tags":[]},{"title":"解决使用gopath时候goget慢的问题","slug":"解决使用gopath时候goget慢的问题","date":"2021-03-04T10:03:48.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/04/解决使用gopath时候goget慢的问题/","link":"","permalink":"https://leconio.github.io/2021/03/04/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8gopath%E6%97%B6%E5%80%99goget%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"在开启 GO111MODULE=on的时候，我们设置 GOPROXY 可以大幅度解决 go get 慢的问题。","text":"在开启 GO111MODULE=on的时候，我们设置 GOPROXY 可以大幅度解决 go get 慢的问题。 go mod 万岁。但是对于一些老旧项目，必须使用 go path 这个方法就不灵了。 使用这个方法首先你要有一个代理，随便买个翻墙工具就行。配置好代理端口，例如 9080。 在 linux 或者 mac 平台使用: 123export ALL_PROXY&#x3D;127.0.0.1:9080git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:9080git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:9080 试试吧！如果上面方法不灵的话怎么办，PS：反正我是不灵的。有一款软件是软件级代理软件，Proxifier 是一款收费软件，提供试用，对于一个 coder 来说，他是我最值得购买的一个软件了。 打开这个软件之后，配置代理，添加规则： 1*.golang.org;*.github.com;*.googlesource.com;*.gopkg.in 如下图： 重新 go get。虽然没有使用 go proxy 快，但是应应急是够了。","categories":[{"name":"Go","slug":"Go","permalink":"https://leconio.github.io/categories/Go/"}],"tags":[]},{"title":"React Native 拆包总结","slug":"React-Native-拆包思想","date":"2021-03-04T09:57:47.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/04/React-Native-拆包思想/","link":"","permalink":"https://leconio.github.io/2021/03/04/React-Native-%E6%8B%86%E5%8C%85%E6%80%9D%E6%83%B3/","excerpt":"在这里使用 Metro 的方式进行拆包，拆包的目的是可以按业务需要进行按需加载，同时可以热更新和热修复。","text":"在这里使用 Metro 的方式进行拆包，拆包的目的是可以按业务需要进行按需加载，同时可以热更新和热修复。 分包思路为：**基础包+业务包 1+业务包 2+…**。 由上面可以看到，app 有原来的一个 bundle 分拆为多个，在 app 启动的时候，先加载公共部分 bundle，启动之后按需加载业务 bundle。每个 bundle 都对应一个容器，在 android 里面是 Activity，而在 iOS 里面是 ViewController。那么就可以理解为把之前单容器 bundle 的 app，拆分为多个容器加载。 规划代码拆分在进行 bundle 拆分之前，我们要制定好方案： 首先我们的代码一般分为：主要代码+依赖+工具+资源 举个例子，如下图： 红色框框里面的是工具代码，在打 bundle 的时候我们把他们排除，不打入 bundle 中。 白色框框里面的是依赖代码，我们选择性打入。 绿色框框里面的是主要代码，我们需要把他们打入到 bundle 中。 资源比较特殊，下面在进行讨论 在上面我们把 bundle 分为公共 bundle和业务 bundle，在分包的时候也是把代码分成上面三个部分，然后装配到不同的 bundle 中的。如下图所示：从上图可以看出，公共 bundle 与业务 bundle 唯一的区别就是多了依赖代码。这么分包的好处是： 公共 bundle 可以做成没有 ui 页面的组件，然后异步加载。在进入业务页面的时候会非常快。 抽离业务模块的依赖部分，打出来的 bundle 会非常小，单独更新 bundle 时候，冗余量非常小。 但是也有一些缺点，你是需要知道的： 业务 bundle 也需要node_module依赖，在所有 bundle 中，如果 package.json 依赖版本不统一，有可能会引发白屏问题。 分包方案这部分要具体问题具体分析，解决痛点才是重要的。 演示为了演示 demo，我们准备两个工程，一个主 bundle，一个业务 bundle。先来对比看一下这两个项目的目录结构。为了方便，我把原生工程（iOS 和 Android）放到公共 bundle 下面，在实际情况中，一般都会新增仓库，由不同的项目组分管。 在这里公共 bundle 仓库中，没有自有代码实现（没有 src 目录），因为 demo 的逻辑没有那么复杂，大家可以具体问题具体分析，放一些一些公共初始化的东西，如推送处理，后台服务等等。 注意：react native 在打包的过程中，如果一个依赖没有被使用到，即使你再 package.json 中声明了它，它也是不会被打包到 bundle 中的，所以为了把公共依赖都打到公共 bundle 中，我们需要在入口文件index.js中声明用到的依赖。 123456789import &quot;react&quot;;import &quot;react-native&quot;;import &quot;react-native-gesture-handler&quot;;import &quot;react-navigation&quot;;import &quot;react-navigation-redux-helpers&quot;;import &quot;react-redux&quot;;import &quot;redux&quot;;import &quot;redux-thunk&quot;;import &quot;react-native-screens&quot;; 小提示：如果在运行过成功发生白屏现象，检查依赖代码（node_modules）是否被打入到公共 bundle 中，如果没有，就要主动声明它们。 打包现在假设你已经指定了自己的分包方案，那么看一下 React Native 是如何生产 bundle 的，又是如何分包的。 React Native 打包命令为： 123456789node ./node_modules/react-native/local-cli/cli.js bundle --platform android --dev false --entry-file index.js --bundle-output ./bundles/base.android.bundle --assets-dest ./bundles/res/android --config ./package.config.js --sourcemap-output ./bundles/base.android.bundle.map --reset-cache --platform android 指定运行平台，ios 平台则指定为 ios。 --dev false 指定为 release 版本。 --entry-file 指定入口文件，程序的主入口。 --bundle-output --assets-dest --sourcemap-output 分别为 bundle 输出路径，资源输出路径，debug 用到的映射文件输出路径，以上三个路径必须存在。 --config 在这里传入分包方案用到的 js 文件。 资源文件推荐直接输出到目的目录中，如果是 android 平台，输出到src/main/res/中 分包由上面可以知道，分包的重点就是 package.config.js 这个文件了。在这里可以把源码 clone 下来，打开 base 工程下的这个文件： 1234567module.exports = &#123; serializer: &#123; createModuleIdFactory: createModuleIdFactory, processModuleFilter: postProcessModulesFilter, /* serializer options */ &#125;,&#125;; 上面代码中，有两个很重要的方法createModuleIdFactory 和 postProcessModulesFilter 。createModuleIdFactory 是给每一个需要打包的文件去一个名字，避免多个 bundle 文件中代码冲突。而postProcessModulesFilter 就是用于标记哪些文件需要打入到 bundle 中的了。这个方法返回 false 表示不打入，true 表示打入。 1234567// Base工程中 打包关键代码if (module[&quot;path&quot;].indexOf(pathSep + &quot;node_modules&quot; + pathSep) &gt; 0) &#123; return true;&#125;if (module[&quot;path&quot;].indexOf(&quot;index&quot;) &gt; 0) &#123; return true;&#125; 在公共依赖 base 工程，我们只打入路径中包含node_modules和入口文件。而在业务工程只打入主要代码和入口文件。如下所示： 1234567891011// 业务工程中 打包关键代码// 提前过滤依赖if (module[&quot;path&quot;].indexOf(pathSep + &quot;node_modules&quot; + pathSep) &gt; 0) &#123; return false;&#125;if (module[&quot;path&quot;].indexOf(pathSep + &quot;src&quot; + pathSep) &gt; 0) &#123; return true;&#125;if (module[&quot;path&quot;].indexOf(&quot;index&quot;) &gt; 0) &#123; return true;&#125; 至此，两个 bundle 和资源文件就生成了。 后续这时候，分包的主要工作已经完成，把打包的产物放到远程工程里面已经可以正常运行。但是工作远远没有结束。首先这两个 bundle 没有任何版本信息，也无法判断时候被伪装。 我们的 bundle 应该做到热替换，如果只在服务器上拉取最新的 bundle，那么就无法保证分区域加载，或者灰度加载。所以我们还需要一个配置文件，用于记录这个 bundle 的日期、版本、灰度区域以及他的 md5 信息。 这个配置文件为 bundle 打完包之后就要生成，同时可以被中台（原生工程读取）。为了方便，我们使用 json 作为文件结构格式。 123456&#123; &quot;create_date&quot;:1595317939331, &quot;version&quot;:&quot;1.0.1&quot;, &quot;update_desc&quot;:&quot;新加了一个弹框&quot;, &quot;md5&quot;:&quot;0ca175b9c0f726a831d895e269332461&quot;&#125; 首先 create_date 就代表这个 config 配置生成时间， version 是当前 bundle 版本号，md5 为打包 bundle 的唯一标识。这个配置文件可以使用脚本生成。 在 package.json 里面新增一个 postxxx ,其中 xxx 为你的打包命令。我使用的是 make，那么就新增 postmake，这样，在执行完成打包命令之后，他会自动执行。如下图 12345&quot;scripts&quot;: &#123; &quot;make&quot;: &quot;node ./node_modules/react-native/local-cli/cli.js bundle --platform android --dev false --entry-file index.js --bundle-output ./bundles/base.android.bundle --assets-dest ./bundles/res/android --config ./package.config.js --sourcemap-output ./bundles/base.android.bundle.map --reset-cache&quot;, &quot;makeiOS&quot;: &quot;node ./node_modules/react-native/local-cli/cli.js bundle --platform ios --dev false --entry-file index.js --bundle-output ./bundles/base.ios.bundle --assets-dest ./bundles/res/ios --config ./package.config.js --sourcemap-output ./bundles/base.ios.bundle.map --reset-cache&quot;, &quot;postmake&quot;:&quot;node aftermake.js&quot;&#125;, 那么这里的aftermake.js ，主要工作就是生成配置文件了，并且把它打包成最终文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var fs = require(&quot;fs&quot;);var crypto = require(&quot;crypto&quot;);var compressing = require(&quot;compressing&quot;);function generateMd5() &#123; return new Promise((resolve, rejects) =&gt; &#123; var stream = fs.createReadStream(&quot;bundles/base.android.bundle&quot;); var fsHash = crypto.createHash(&quot;md5&quot;); stream.on(&quot;data&quot;, function (d) &#123; fsHash.update(d); &#125;); stream.on(&quot;end&quot;, function () &#123; var md5 = fsHash.digest(&quot;hex&quot;); resolve(md5); &#125;); &#125;);&#125;async function readPackageInfo() &#123; return new Promise((resolve, rejects) =&gt; &#123; fs.readFile(&quot;package.json&quot;, function (err, data) &#123; if (err) &#123; rejects(err); return; &#125; var package = JSON.parse(data); resolve([package.version, package.update_desc]); &#125;); &#125;);&#125;async function writeToFile(info) &#123; fs.writeFile(&quot;bundles/config.json&quot;, JSON.stringify(info), function (err) &#123; if (err) &#123; return console.error(err); &#125; &#125;);&#125;async function main() &#123; let info = await readPackageInfo(); let md5 = await generateMd5(); const config = &#123; create_date: new Date().getTime(), version: info[0], update_desc: info[1], md5: md5, &#125;; await writeToFile(config); await compressing.zip.compressDir(&quot;bundles&quot;, &quot;base.zip&quot;);&#125;main(); 生成 base.zip 。这 zip 就可以放到应用分发平台，等待上线。 源码地址：https://github.com/leconio/ReactNativeInPlatform","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://leconio.github.io/categories/ReactNative/"}],"tags":[]},{"title":"Android 设备通过WIFI传输数据 - 点对点传输","slug":"Android-设备通过WIFI传输数据-点对点传输","date":"2021-03-04T09:56:47.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/04/Android-设备通过WIFI传输数据-点对点传输/","link":"","permalink":"https://leconio.github.io/2021/03/04/Android-%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87WIFI%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BC%A0%E8%BE%93/","excerpt":"点对点传输（P2P）又是 WLAN 直连，他可以在没有中间接入点的情况下，通过 WLAN 进行直接互联。","text":"点对点传输（P2P）又是 WLAN 直连，他可以在没有中间接入点的情况下，通过 WLAN 进行直接互联。他有用户介入操作少，比蓝牙传输速度高等特点，对设备的要求仅仅为 14，同时他又不占用 wlan0 网卡。 WLAN P2P 需要使用到 WifiP2pManager ，同时需要以下权限，这里面有一些是运行时权限，需要用户同意后才能使用。 1234567&lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 点对点传输（P2P）至少有两个有 Wifi 的设备，其中一个是 Android，首先确定 Android 设备和另外一个设备是否支持 P2P 连接。把手机连接电脑运行 adb shell ip addr|grep p2p0 -A2有输出就带边可以使用，一般来说都可以使用。 1229: p2p0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000 link/ether 02:00:2d:63:a5:6b brd ff:ff:ff:ff:ff:ff 注意看上面的输出，link/ether 02:00:2d:63:a5:6 为 p2p 的 Mac 地址，不同的设备之间使用 Mac 地址连接，所以首先要知道 P2P（p2p0）的 Mac 地址，这个和 wifi（wlan0）的地址不是同一个，在代码中需要使用下面方法获取。 12345678910111213141516171819202122232425262728public static String getLocalMacAddress() &#123; try &#123; List&lt;NetworkInterface&gt; interfaces = Collections.list(NetworkInterface.getNetworkInterfaces()); for (NetworkInterface ntwInterface : interfaces) &#123; if (ntwInterface.getName().equalsIgnoreCase(&quot;p2p0&quot;)) &#123; byte[] byteMac = ntwInterface.getHardwareAddress(); if (byteMac == null) &#123; return null; &#125; StringBuilder strBuilder = new StringBuilder(); for (int i = 0; i &lt; byteMac.length; i++) &#123; strBuilder.append(String.format(&quot;%02X:&quot;, byteMac[i])); &#125; if (strBuilder.length() &gt; 0) &#123; strBuilder.deleteCharAt(strBuilder.length() - 1); &#125; return strBuilder.toString(); &#125; &#125; &#125; catch (Exception e) &#123; Log.d(&quot;Lecon&quot;, e.getMessage()); &#125; return null;&#125; 接下来看一下如何主动连接到 p2p 设备。 使用方法首先通过 WifiP2pManager 的 initialize 初始化。 1234567val manager: WifiP2pManager? by lazy(LazyThreadSafetyMode.NONE) &#123; getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager?&#125;override fun onCreate(savedInstanceState: Bundle?) &#123; mChannel = manager?.initialize(this, mainLooper, null)&#125; 同时使用广播来接受各种 P2P 连接的状态变化。 1234567891011121314151617181920var mChannel: WifiP2pManager.Channel? = nullvar mReceiver: WiFiDirectBroadcastReceiver? = nullprivate val mWifiP2pManager: WifiP2pManager by lazy(LazyThreadSafetyMode.NONE) &#123; getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager&#125;private val mIntentFilter: IntentFilter by lazy(LazyThreadSafetyMode.NONE) &#123; IntentFilter().apply &#123; addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION) addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION) addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION) addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION) &#125;&#125;override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) mChannel = mWifiP2pManager.initialize(this, mainLooper, null) mReceiver = WiFiDirectBroadcastReceiver(mWifiP2pManager, mChannel, this) 12345678910111213141516171819class WiFiDirectBroadcastReceiver( private val mManager: WifiP2pManager?, private val mChannel: WifiP2pManager.Channel?, private val mActivity: MainActivity) : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; val action = intent.action if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION == action) &#123; // 当 WLAN P2P 在设备上启用或停用时广播 &#125; else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION == action) &#123; // 调用 requestPeers() 方法，以获得当前所发现对等设备的列表。 // 同时 在这里调用 connect 方法连接对方机器 &#125; else if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION == action) &#123; // 当设备的 WLAN 连接状态更改时广播。 // 连接对方机器成功或者失败都会在这里回调 &#125; else if (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION == action) &#123; // 当设备的详细信息（例如设备名称）更改时广播 &#125;&#125; 上边哪一些代码可以当成主动发起扫描之后的回调，使用广播进行回调说起来真的是挺复杂的，但是仔细想想，操作硬件设备本来就是跨进程的，而且这个还是长时间耗时操作，系统通过广播回调也是合理的。 到现在位置，可以把以上代码运行到 Android 上，他就可以最为 P2P 连接的被连接端。 连接到设备连接到设备的时候，首先要确定对方设备的 mac 地址，上面的两种方法是针对于 Android 设备的。一种是 adb 方式，一种是代码获取。 接下来要发现设备： 123456789mWifiP2pManager.discoverPeers(mChannel, object : WifiP2pManager.ActionListener &#123; override fun onSuccess() &#123; Toast.makeText(this@MainActivity, &quot;已发现设备，准备连接&quot;, Toast.LENGTH_SHORT).show() &#125; override fun onFailure(reasonCode: Int) &#123; &#125;&#125;) 返现设备之后，通过广播回调的 WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION 事件获取设备列表。找到列表中的设备与被连接设备 mac 地址一致的，确保我们被连接机器已经就绪。 1234567mManager?.requestPeers(mChannel) &#123; peers -&gt; for (device in peers.deviceList) &#123; if (mac != null &amp;&amp; mac.equals(device.deviceAddress, ignoreCase = true)) &#123; connectToDevice(device) &#125; &#125;&#125; 接下来就可以连接设备了！ 123456789val config = WifiP2pConfig()config.deviceAddress = &quot;被连接设备的Mac地址&quot;mManager?.connect(mChannel, config, object : WifiP2pManager.ActionListener &#123; override fun onSuccess() &#123; Toast.makeText(mActivity, &quot;连接成功&quot;, Toast.LENGTH_SHORT).show() &#125; override fun onFailure(reason: Int) &#123;&#125;&#125;) 如果被连接设备是 Android，你应该能看到一个连接提示，点击接受这样两台设备之间就连接成功了，通过 WIFI 两个设备可以实现近场通讯。 通信通信之前需要知道被连接设备的 ip 地址。如果是 android 设备，在被连接设备执行adb shell ip addr|grep p2p0 -A4 就可以看到，这也是检测是否连接成功的方法。代码获取仍然要获取 p2p0 网卡的，wlan0 获取的 ip 地址不能用于这里。 1234567891011121314151617181920212223public static String getLocalIp() &#123; try &#123; List&lt;NetworkInterface&gt; interfaces = Collections .list(NetworkInterface.getNetworkInterfaces()); for (NetworkInterface intf : interfaces) &#123; if (!intf.getName().contains(&quot;p2p0&quot;)) continue; List&lt;InetAddress&gt; addrs = Collections.list(intf .getInetAddresses()); for (InetAddress addr : addrs) &#123; if (!addr.isLoopbackAddress()) &#123; return addr.getHostAddress().toUpperCase(); &#125; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return &quot;&quot;;&#125; 如果被连接设备是一台服务器（在 Android 里面搭建一台服务器也是可以的），在这台设备上可以用 okhttp 等框架进行网络访问，或者使用 socket 进行传输。现在两个手机（P2P）设备之间就可以同过 WLAN 直接通信了。 下面是源代码：https://github.com/leconio/WifiDircetP2PDemo","categories":[{"name":"Android","slug":"Android","permalink":"https://leconio.github.io/categories/Android/"}],"tags":[]},{"title":"Kotlin 封闭类与枚举区别","slug":"Kotlin-封闭类与枚举区别","date":"2021-03-04T09:55:31.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/04/Kotlin-封闭类与枚举区别/","link":"","permalink":"https://leconio.github.io/2021/03/04/Kotlin-%E5%B0%81%E9%97%AD%E7%B1%BB%E4%B8%8E%E6%9E%9A%E4%B8%BE%E5%8C%BA%E5%88%AB/","excerpt":"区别就是一个是静态的一个是动态的…","text":"区别就是一个是静态的一个是动态的… Kotlin 封闭类与枚举区别在 Java 或者 Kotlin 中枚举可以携带属性，向下面这样。使用属性可以做一些差异性判断，比如静态工厂。 123enum class Car2(val maxSpeend:Int) &#123; AUDI(200),BWM(210),BENZ(220)&#125; 但是在实际开发中，有一些属性并不是直接就能确定的，甚至随着程序的运行才能确定，就用到了封闭类。举个例子： 12345678910111213141516171819202122232425262728293031sealed class Car3(val maxSpeed:Int) &#123; object AUDI:Car3(200) object BWM:Car3(210) object BENZ:Car3(220) class CustomCar1(val m:Int) :Car3(DEFAULT_MAX_SPEED) class CustomCar2(val m:Int) :Car3(DEFAULT_MAX_SPEED) companion object &#123; const val DEFAULT_MAX_SPEED = 200 &#125;&#125;fun race(car:Car3) &#123; when(car) &#123; Car3.AUDI -&gt; println (&quot;AUDI max_speed is &quot; + Car3.AUDI.maxSpeed) Car3.BWM -&gt; println(&quot;BWM max_speed is &quot; + Car3.BWM.maxSpeed) Car3.BENZ -&gt; println(&quot;BENZ max_speed is &quot; + Car3.BENZ.maxSpeed) is Car3.CustomCar1 -&gt; println(&quot;CustomCar1 max_speed is &quot; + (car.maxSpeed + car.m)) is Car3.CustomCar2 -&gt; println(&quot;CustomCar2 max_speed is &quot; + (car.maxSpeed + car.m)) else -&gt; Car3.DEFAULT_MAX_SPEED &#125;&#125;fun main() &#123; race(Car3.AUDI) race(Car3.BENZ) race(Car3.CustomCar1(30))&#125; 在上面代码中，封闭类 Car3 中AUDI BWM BENZ的最大速度已经确定，直接写死在代码中。但是有一些数据是从数据库读取或者用户人为输入的，比如上面的 CustomCar1，他的最大速度可以使用构造器传入，在上面的main函数中。 在实际开发中，封闭类可以看做枚举类的一个拓展，这也是我用封闭类最多的地方。比如说放到回调接口中： 1234sealed class Result&lt;out R&gt; &#123; data class Success&lt;out T&gt;(val data: T) : Result&lt;T&gt;() data class Error(val exception: Exception) : Result&lt;Nothing&gt;()&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://leconio.github.io/categories/Android/"}],"tags":[]},{"title":"apk 拆包替换文件","slug":"拆包替换文件","date":"2021-03-04T09:51:53.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/04/拆包替换文件/","link":"","permalink":"https://leconio.github.io/2021/03/04/%E6%8B%86%E5%8C%85%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6/","excerpt":"在 Android 的开发测试过程中，为了替换 assets 文件或者更改 smail 文件，需要把 apk 拆开。","text":"在 Android 的开发测试过程中，为了替换 assets 文件或者更改 smail 文件，需要把 apk 拆开。这个过程用到 apktool 和 jarsigner。其中 apktool 需要自己安装；jarsigner 是 jdk 自带的，也就是说需要 java 开发环境。 apktool 安装地址：https://ibotpeaches.github.io/Apktool/ 如果你使用 mac 系统，可以使用 homebrew 安装。 1brew install apktool 其他系统参照官方方法：https://ibotpeaches.github.io/Apktool/install/ 使用方法： 12345拆包：apktool d [apk路径]封包：apktool b [拆包产生的文件夹] 拆包使用apktool d 指令，执行完成之后生成同名目录，封包使用apktool b指令，此时生成 apk 文件，但是这个 apk 是未签名的。不能对手机上已经安装的 apk 进行替换，下面进行签名。jarsigner 是 jdk 自带，不需要额外安装。 1jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore [keystore路径] -storepass [密码] -signedjar [输出apk路径] [输入apk路径] [别名] 不同的 apk 签名可能不相同，使用 jarsigner —help 查看使用规则，现在的 jdk 都是兼容中文的，不用担心看不懂。","categories":[{"name":"Android","slug":"Android","permalink":"https://leconio.github.io/categories/Android/"}],"tags":[]},{"title":"使用frp访问公司内部网络","slug":"使用frp访问公司内部网络","date":"2021-03-03T21:20:56.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/03/使用frp访问公司内部网络/","link":"","permalink":"https://leconio.github.io/2021/03/03/%E4%BD%BF%E7%94%A8frp%E8%AE%BF%E9%97%AE%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C/","excerpt":"观看之前，建议你有 ssh 和简单的 shell 使用经验。","text":"观看之前，建议你有 ssh 和简单的 shell 使用经验。 顾名思义，这是一个通过内网穿透自建 vpn 来访问公司内网的教程。说到内网穿透、vpn 都不是什么新鲜的概念，但是这些工具组合起来确实有很多好玩的地方。在这里，就是他们其中的一种组合游戏。好戏开始之前，我们先提出几个疑问，让我猜猜你想的对不对。 1. 我在家里可以访问公司内网吗，比如打卡，收发邮件之类的？ 2. 我需要哪些必备的东西呢？ 3. frp是个什么工具？ 那么，带着疑问我们开始吧！ 实现原理frp一句话来说就是，通过 frp 把公司计算机的 ssh 暴露出来，个人计算机使用公司计算机 ssh 的 socks5 代理进行上网。 首先介绍一下 frp 这个软件，经常做微信开发的小伙伴应该有接触到，它是搞内网穿透的。在调试公众号或者小程序接口的时候，需要把开发服务器映射到公网上，这样微信服务器才能成功回调到开发者计算机。但是，我们开发计算机在局域网呀，在使用 NAT 转换之后，公网服务器无法直接访问局域网计算机；也就是说，我可以访问互联网，但是互联网无法主动访问我。frp 就是解决这个问题的，它把我自己的计算机的 web 服务放到公网上，然后我们就可以从互联网访问到它。 那么话说回来了，这和今天这个话题有什么联系呢？我们要让个人计算机使用公司的计算机网络进行网络访问，就必须把公司的计算机暴露在互联网当中。如下图： 其实你已经注意到了：把公司计算机直接暴露在公网，会不会不安全呀？当然会，实际使用过程中，一定要按需开启，并且使用安全验证。 frp 不仅仅能把 web 服务暴露在公网，而且还可以把 ssh 服务暴露在公网上。也就是说，我可以通过个人计算机直接 ssh 公司的内网的计算机。 ssh代理我们使用的是 ssh 的 socks5 代理，ssh 有这样一个功能，就是把 ssh 服务器当成一个 socks5 正向的代理，把监听到 socks5 服务端口的流量转发到 ssh 服务器上。就可以实现个人计算机通过公司内网计算机进行上网了。 下面介绍需要用到的设备以及环境。 原材料上面说到，要想实现必须有三台计算机。首先，公司的个人电脑和家中的电脑是其中两个，还需要一个公网电脑进行数据中转。 流量转发端流量转发端是公网中转计算机，它是什么呢？简言之就是有独立 ip 的服务器，这个很容易就买到了，比如阿里云或者腾讯云什么的，很多小伙伴在双 11 和和双 12，被他们冲了一波业绩吧！现在用起来吧，我这里环境使用 Centos7，使用 Ubuntu 的小伙伴也关系，只是防火墙设置不同而已。 流量提供端流量提供端为公司的计算机，必须支持 ssh 服务，Linux 和 Mac 原生支持了，Windows 需要额外下载软件进行支持，比如 Windows10 的内置 Ubuntu，我这里使用 Mac 系统。 流量消费端流量消费端为个人计算机，可以是 Mac、Linux，或者 Windows，Android，后两个需要额外软件，iOS 没有试过。我这里使用 Mac 系统。 我个人不建议使用 Windows 最为搭建这套环境，Windows 下的 Linux 子环境实在是难以折腾，即使通过虚拟机或者 bash 等折腾成功，还要考虑网络问题。 搭建过程搭建过程分为以下几步。 1. 在中转服务器和公司计算机之间搭建frp服务。 2. 个人计算机可以通过ssh访问公司计算机。 3. 把个人计算机的ssh流量作为局部代理 4. 设置局部代理 这样一来工作就清晰了起来！ 1. 搭建 frp 服务frp 分为客户端和服务端两个软件，我们可以从 https://github.com/fatedier/frp/releases 获得（他们在同一个压缩内）。其中 frps 是服务器端，frpc 是客户端。把 frps 放到中转服务器，把 frpc 放到公司计算机。 同时，不管设计 frps 还是 frpc，都仅仅需要一个软件和一个配置文件即可运行。 搭建中转服务器的 frps 服务（操作中转服务器）这一步的目的是建立 frp 服务器。首先 ssh 到中转服务器，下载 frp 软件 12wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.23.2&#x2F;frp_0.23.2_linux_amd64.tar.gztar -zxvf frp_0.23.2_linux_amd64.tar.gz 得到解压的文件，我们只需关注 frps 和 frps.ini 这两个，其他的可以删除。编辑 frps.ini 12[common]bind_port &#x3D; 7000 然后运行 frp 服务端。 1.&#x2F;frpc -c .&#x2F;frpc.ini 当然，为了方便使用，也可以后台运行。 1nohup .&#x2F;frpc -c .&#x2F;frpc.ini &amp; 搭建公司计算机的 frpc 服务（操作公司计算机）这一步要打通公司计算机和中转服务器之间的连接。在这之前，首先要确定公司的计算机时候开启 ssh 服务器。Linux 默认都会开启，Windows 用户只能去找软件来使用，其中 Bitvise SSH Server 还不错，使用起来也比较简单，只是收费。Mac 系统参考如下： 系统偏好设置 -&gt; 共享 -&gt; 远程登录。勾选上，然后在右边添加自己用户。设置好 ssh 服务之后，请下载 frp 客户端软件。这里需要 frpc 和 frpc.ini 这两个文件，其他都可以删除掉。 下载时候要选择好对应平台再下载。客户端和服务端如果系统平台不一样，就不能用同一份（虽然客户端和服务端在同一个文件夹中）。 然后编辑 fric.ini 123456789[common]server_addr &#x3D; x.x.x.xserver_port &#x3D; 7000[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000 注意，这里虽说是在设置公司计算机的客户端配置，但是涉及的到两个端口7000和6000，在中转服务器中也需要添加防火墙例外规则，腾讯云或则阿里云好像还要添加安全组。 其中，x.x.x.x为你中转服务器的公网 ip。server_port是中转服务器和公司服务器通信的端口，remote_port是 ssh 的虚拟端口，我们连接时候指定的端口就是它。其他的参数都无关紧要，具体可以了解 https://github.com/fatedier/frp 。 现在启动公司计算机的 frp 客户端 1.&#x2F;frpc -c .&#x2F;frpc.ini 到这里，主要工作基本上已经完成了，现在就来测试一下是否可以从个人计算机通过 ssh 连接到公司的计算机吧。 2. SSH 到公司计算机（操作个人计算机）如果使用的是 mac 或者 linux 可以直接使用下面的命令，连接到公司计算机。如果是 windows，需要下载 putty 或者 linux 子系统等 ssh 软件（后文提到）。 1ssh -oPort&#x3D;6000 [用户名]@x.x.x.x 其中，x.x.x.x 是你中转服务器的公网 ip。注意这里一定要加上面指定的端口，不然会连接到中转服务器的 ssh 服务。不出什么问题，就可以连接到公司计算机了。 在这个过程中，如果很久都没连接上，或者被远程主动关闭，请检查防火墙的设置。我们可以使用 telnet 命令测试远程端口是否开启。 教程到这里，好像和 vpn 好像还没有什么太大的关系，仅仅是可以控制公司的计算机而已。不要忘记，ssh 有一个很好的功能，就是把远程服务器的流量，变成本地计算机的 socks5 代理。 3. 设置 ssh 的 socks5 代理（操作个人计算机）好的，现在可以按 control+c 停止连接。然后，Linux 用户和 Mac 用户可以直接输入以下命令直接开启 sock5 隧道。 1ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 [公司计算机账户]@[中转服务里ip] 比如 1ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 spawn@192.168.2.1 注意以上命令，这里又多出一个 1080 的端口，这个端口是为本地开的。任何把代理端口指向这个位置的连接，都可以使用这个代理，所以这里要记住这个端口。 如果你想让局域网其他电脑也可以访问，那么把 127.0.0.1 换成 0.0.0.0。 注意：ssh 的 sock5 代理如果长时间不使用会自动断开连接，当然，使用autossh可以解决这个问题。 Windows 用户需要额外的软件，推荐使用 putty。操作步骤如下：打开 putty其中 x.x.x.x 为中转服务 ip，端口填写 6000 按照上图操作步骤操作然后检查路由表，看看是否正常开启。 1netstat -n -a 到此 Windows 可以开启一个端口为 1080 的 sock5 隧道开启 sock5 隧道之后，怎么能检测一下呢？打开一个新的 Shell，输入 12export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080curl cip.cc 注意，上面的 1080 就是之前预留的端口，地址 127.0.0.1 指向本地。接下来使用上面命令看一看公网 ip 是不是和公司计算机的一样。（PS. 公司计算机也可以输入这个命令查看，或者直接百度关键字 ip。如果相同，那么以上过程就全部成功了！ 插个题外话，如果把公司计算机去掉，直接连接中转服务器的 ssh 服务的话，你懂得~。ssh 比 pptp 和 l2tp 要爽哦，关键日子那几天，纸飞机隧道都不可用，全靠它呢！！！ 接下来，有了 sock5 代理，按理说文章应该可以结束了。但是毕竟还没有看到效果，那么接下来简单说说它的几种食用方式，这个过程可以任意发挥，没有固定方式！ 通过局部代理上网上面我们说到，如何把 ssh 流量变成 socks5 局部代理，那么现在就是怎么使用这个局部代理了。 命令行代理这种代理方式只在当前 session 生效，一旦关闭当前命令行，就会失效。 123开启方式 export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080关闭方式 export ALL_PROXY&#x3D;检验方式 curl cip.cc Mac 全局代理系统偏好设置 -&gt; 网络 -&gt; 高级 -&gt; 代理 -&gt; socks 代理 勾选这个点击确定。 Chrome 插件分网址代理推荐使用插件 SwitchyOmega，由于本教程不是讲局部代理使用方式，直接贴这个插件的使用教程 https://github.com/FelisCatus/SwitchyOmega 。使用SwitchyOmega可以针对不同网页使用不同的代理方式，比如说，1080 端口是访问公司内网的，1088 端口是土啬的。它还可以破除公司对于某些网站的限制，同时也代理就不用切来切去了，十分方便。 Proxifier 分应用代理使用 SwitchyOmega 可以在访问不同网站的时候使用不同的代理设置，那么 Proxifier 就可以针对于不同的应用使用不同的代理，甚至切断互联网连接。或者我们可以把上面教程反过来玩，然公司服务器当个人计算机，家中的电脑扮演公司计算机的角色。使某些 App 走家中的流量，就可以简单破除公司对于某些 App 的网路限制，比如微信或者音乐视频类软件，但是要注意 dns 的设置。 它是一个十分优秀的软件，但是需要付费。如果是针对外企用户需要频繁切换网络的用户来说，它的确是一个福音。 注意事项一般来说，公司的网络安全部都不会允许把公司计算机暴露在公网之下，本文只讨论技术，大家好好玩儿~ 2021 年 3 月 2 日更新使用nps后者goproxy过程会更简单 - -","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"Android的Binder的调用方面","slug":"Android的Binder的调用方面","date":"2021-03-03T21:07:07.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2021/03/03/Android的Binder的调用方面/","link":"","permalink":"https://leconio.github.io/2021/03/03/Android%E7%9A%84Binder%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2/","excerpt":"从 Binder 的远程方法调用来看，Proxy 是调用端，Stub 是被调用端。","text":"从 Binder 的远程方法调用来看，Proxy 是调用端，Stub 是被调用端。 由 AIDL 的 Interface 实现类，可以看出： 123456789101112131415161718public java.util.List&lt;com.leconio.aidlsender.Person&gt; getPersons() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.leconio.aidlsender.Person&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getPersons, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; return getDefaultImpl().getPersons(); &#125; _reply.readException(); _result = _reply.createTypedArrayList(com.leconio.aidlsender.Person.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; 先获取两个 Parcel，一个用于传递数据，一个用于接收数据。每个 Parcel 中都有一个mNativePtr，是个 long 类型，其实他是 JNI 中的 Parcel，由 reinterpret_cast 转换而来。也就是说，Java 层的 Parcel 包裹着 JNI 层的 Parcel。Parcel 是在一个 Parcel 池中获取，这个池大小是 6。mNativePtr 会在 CPP 代码中 Parcel 初始化的时候被初始化。 123456static jlong android_os_Parcel_create(JNIEnv* env, jclass clazz)&#123; sp&lt;ParcelRef&gt; parcelRef = ParcelRef::create(); parcelRef-&gt;incStrong(reinterpret_cast&lt;const void*&gt;(android_os_Parcel_create)); return reinterpret_cast&lt;jlong&gt;(static_cast&lt;Parcel *&gt;(parcelRef.get()));&#125; 上面代码中mRemote的实现类是 Java 层的ProxyBinder，这个地方就调用到了 ProxyBinder 中的transact。 12345678910111213141516public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; ... try &#123; return transactNative(code, data, reply, flags); &#125; finally &#123; AppOpsManager.resumeNotedAppOpsCollection(prevCollection); if (transactListener != null) &#123; transactListener.onTransactEnded(session); &#125; if (tracingEnabled) &#123; Trace.traceEnd(Trace.TRACE_TAG_ALWAYS); &#125; &#125;&#125; 调用到了 cpp 层的transactNative 1234567891011// android_os_BinderProxystatic jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jboolean replyObjOwnsNativeParcel, jint flags) // throws RemoteException&#123; ... IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); // 获取BPBinder ... status_t err = target-&gt;transact(code, *data, reply, flags); // 由BPBinder再次传递 ...&#125; 12345678// BpBinder.cppstatus_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); // 由IPCThreadState传递给驱动&#125; 如果有 reply 的话 12345678910111213// BpBinder.cppstatus_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; ... if (reply) &#123; err = waitForResponse(reply); // 等待回复 &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; ...&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// IPCThreadState.cppstatus_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; // 无限循环等待结果 if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Processing waitForResponse Command: &quot; &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; switch (cmd) &#123; ... case BR_REPLY: // 如果返回消息 &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer); // 设置返回值 &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); &#125; &#125; else &#123; freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); continue; &#125; &#125; goto finish; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125;&#125; 上面的 reply 是 Parcel。我们看看Parcel::ipcSetDataReference。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Parcel.cppvoid Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const binder_size_t* objects, size_t objectsCount, release_func relFunc)&#123; freeData(); mData = const_cast&lt;uint8_t*&gt;(data); // 设置值 mDataSize = mDataCapacity = dataSize; mObjects = const_cast&lt;binder_size_t*&gt;(objects); mObjectsSize = mObjectsCapacity = objectsCount; mOwner = relFunc; binder_size_t minOffset = 0; for (size_t i = 0; i &lt; mObjectsSize; i++) &#123; binder_size_t offset = mObjects[i]; if (offset &lt; minOffset) &#123; ALOGE(&quot;%s: bad object offset %&quot; PRIu64 &quot; &lt; %&quot; PRIu64 &quot;\\n&quot;, __func__, (uint64_t)offset, (uint64_t)minOffset); mObjectsSize = 0; break; &#125; const flat_binder_object* flat = reinterpret_cast&lt;const flat_binder_object*&gt;(mData + offset); uint32_t type = flat-&gt;hdr.type; if (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE || type == BINDER_TYPE_FD)) &#123; // We should never receive other types (eg BINDER_TYPE_FDA) as long as we don&#x27;t support // them in libbinder. If we do receive them, it probably means a kernel bug; try to // recover gracefully by clearing out the objects, and releasing the objects we do // know about. android_errorWriteLog(0x534e4554, &quot;135930648&quot;); ALOGE(&quot;%s: unsupported type object (%&quot; PRIu32 &quot;) at offset %&quot; PRIu64 &quot;\\n&quot;, __func__, type, (uint64_t)offset); releaseObjects(); mObjectsSize = 0; break; &#125; minOffset = offset + sizeof(flat_binder_object); &#125; scanForFds();&#125; 上面代码中，设置了返回值 mData。","categories":[{"name":"黑洞","slug":"黑洞","permalink":"https://leconio.github.io/categories/%E9%BB%91%E6%B4%9E/"}],"tags":[]},{"title":"Dart对比java快速入门","slug":"Dart对比java快速入门","date":"2020-03-03T21:38:18.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2020/03/03/Dart对比java快速入门/","link":"","permalink":"https://leconio.github.io/2020/03/03/Dart%E5%AF%B9%E6%AF%94java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"首先本文是通过对比其他语言（主要是 java）快速入门","text":"首先本文是通过对比其他语言（主要是 java）快速入门 定位首先本文是通过对比其他语言（主要是 java）快速入门，建议您至少要熟悉一门静态语言或者动态语言。Dart 和 java 以及 C#都差不多，基本上不用学习可以直接使用，从这里可以你可以了解 Dart 有些特别之处。 首先从一段代码入门吧： 123456789void main() &#123; for (int i = 0; i &lt; 5; i++) &#123; printTest(&#x27;hello $&#123;i + 1&#125;&#x27;); &#125;&#125;void printTest(String variableInteger) &#123; print(variableInteger);&#125; 从上面可以看到，Dart 语言主入口是main函数，他可以不用属于某个类。一眼看上去和 java 差不多。流程控制也是由小括号和大括号构成，不用考虑缩进。结尾必须要加上分号。 声明数据类型12345678void main() &#123; int l = 4; String str1 = &quot;str1&quot;; var i = 1; dynamic d = 0; final j = 2; const k = 3;&#125; Dart 是强类型语言，变量都会有一个类型。你可以向 java 那样直接声明类型，同样可以像 swift 或者 Kotlin 那样使用类型推导。Dart 的类型推导使用 final,var,const,dynamic 关键字。 var修饰变量，这个没什么好说的。 final表示不可变的，修饰内置数据类型，值不可变；修饰对象表示引用不可变，使用到的频率很高。 const是编译时常量，他表示始终不可变，无论修饰内置类型还是对象，或者是数据结构。 dynamic是任意类型，有点像 java 里面的Object，Kotlin 中的Any。 使用 const 修饰的都是编译时常量。它区别于运行时，它的值是不可变的。所有的数据类型，不管是 int 还是 String，初始值都是null 数据类型numbers、strings 和 booleans首先是numbers,strings,booleans其中 numbers 包括int和double类型，分别表示整数和浮点数。strings 就是String类型，普通的字符串。booleans 类型是bool只包含true和false。 numbers * int * double strings * String booleans * bool 如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142void main() &#123; // numbers int i = 1; double d = 1.1; // 字符串转数字 // 这里就使用了类型推导 final p1 = &quot;3&quot;; final p2 = &quot;3.3&quot;; print(int.parse(p1)); print(double.parse(p2)); // string // 可以使用（&#x27;xxx&#x27;）（&quot;xxx&quot;）（&#x27;&#x27;&#x27;xxx&#x27;&#x27;&#x27;） 三种方式初始化字符串，和Kotlin很像。 // 字符串比较的是值 final str1 = &quot;test&quot;; final str2 = &quot;test&quot;; print(str1 == str2); // true final str3 = &#x27;test&#x27;; print(str3); final str4 = &#x27;&#x27;&#x27;test&#x27;&#x27;&#x27;; print(str4); print(str4 == str3); // true print(&quot;I&#x27;m $&#123;str4&#125;!!!&quot;); //booleans // null 可以直接用来判断，它是false if(null) &#123; print(&#x27;null is true&#x27;); &#125; else &#123; print(&#x27;null is false&#x27;); &#125; print(&#x27;&#x27;.isEmpty);// final list = [];// if(!list) &#123;// print(&#x27;not empty&#x27;);// &#125;&#125; Dart 的数据结构包括 list 和 map listlist对应的就是 java 里面的 List，list 可以像 Python 等语言那样使用[]进行数组操作，参照以下示例代码。List 有几个在 flutter 非常常用的初始化方式，分别为filled和generate。具体参考：https://api.dartlang.org/stable/2.1.0/dart-core/List-class.html 12345678910111213141516171819202122232425262728293031void main() &#123; // 初始化 final list1 = [1,2,3,4,5]; // 编译时常量 final list2 = const [2,3,4,5,6];// list2[2] = 8; error print(list2); // 初始化2 List&lt;int&gt; list3 = new List(5); print(list3); // [null, null, null, null, null] // 初始化3 filled 第一个参数是个数，第二个是添加的值 List&lt;int&gt; list4 = List.filled(3,10); print(list4); // [10,10,10] // 初始化4 类似Python的Map生成 List&lt;int&gt; list5 = List.generate(3,(i) =&gt; i * 3); print(list5); // [0, 3, 6] // 更改 使用list1 list1[2] = 8; print(list1); // [1, 2, 8, 4, 5] // 添加 list1.add(10);// list1[10] = 20; Index out of range print(list1); // [1, 2, 8, 4, 5, 10] //删除 list1.remove(10); print(list1); // [1, 2, 8, 4, 5]&#125; mapmap 对应 java 里面的 Map，他的操作方式有点像 Python。需要注意的有几点。 Map 的 Key 不能有重复的 如果使用 int 类型作为 key，取值的时候优先使用 key 匹配，然后是下标。 取不到值不会抛异常，直接返回 null Map 和 List 可以转换为 Json,来回转换时深拷贝。 其他 API 参考：https://api.dartlang.org/stable/2.1.0/dart-core/Map-class.html 123456789101112131415161718192021222324252627282930313233343536373839404142import &#x27;dart:convert&#x27;;void main() &#123; final map1 = &#123; &quot;test1key&quot; : &quot;test1value&quot;,// &quot;test1key&quot; : &quot;test1value&quot;, Key 不能相同 123 : &quot;123value&quot;, null : &#x27;NULL&#x27;, 2 : &#x27;2&#x27; &#125;; print(map1); // &#123;test1key: test1value, 123: 123value, null: NULL, 2: 2&#125; // 获取值 print(map1[123]); // key取值 123value print(map1[1]); // 下标取值 null print(map1[2]); // 同时存在时候，优先Key取值；结果为 2 // 追加值 map1[&#x27;appendKey&#x27;] = &#x27;appendVal&#x27;; print(map1); // 更改值 map1[&#x27;appendKey&#x27;] = &#x27;appendVal123&#x27;; print(map1); map1[&#x27;appendKey&#x27;] = null; print(map1); // 置为null之后，key不会消失 map1.remove(&#x27;appendKey&#x27;); // 删除 print(map1); print(map1[&#x27;non-key&#x27;]); // 不会报错 打印 null print(map1.length); // 长度 4 // json 转换 // 使用const修饰的数据结构，不可改变。 final map2 = const &#123; &quot;name&quot;:&quot;lecon&quot;, &quot;age&quot;:23, &quot;ss&quot;:[1,2,3,4,4] &#125;; final jsonText = jsonEncode(map2); print(jsonText); // &#123;&quot;name&quot;:&quot;lecon&quot;,&quot;age&quot;:23,&quot;ss&quot;:[1,2,3,4,4]&#125; final mapObj = jsonDecode(jsonText); print(mapObj); // &#123;name: lecon, age: 23, ss: [1, 2, 3, 4, 4]&#125;&#125; Runes这东西其实就是字符集的扩编，可以用它显示一些表情符号 12345678910main() &#123; var clapping = &#x27;\\u&#123;1f44f&#125;&#x27;; print(clapping); print(clapping.codeUnits); print(clapping.runes.toList()); Runes input = new Runes( &#x27;\\u2665 \\u&#123;1f605&#125; \\u&#123;1f60e&#125; \\u&#123;1f47b&#125; \\u&#123;1f596&#125; \\u&#123;1f44d&#125;&#x27;); print(new String.fromCharCodes(input));&#125; 函数Dart 的函数比 java 多了几个概念。比如在参数列表里面添加个大括号，是可选命名参数；加个中括号叫可选位置参数。 可选命名参数类似 Python 里面的**kwargs，参考下面示例代码func3； 可选位置参数类似 Python 里面的*args，参考下面func5。 可选命名参数和可选位置参数可以有默认值，普通参数不能有，参考func6。 函数之间可以互相嵌套，互相调用，但他们都有自己作用域。 若果函数简单可以使用()=&gt; value简写。 比如 123String test() &#123; return &quot;123&quot;;&#125; 简写成 1String test ()=&gt; &quot;123&quot;; 下面是示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// import &#x27;package:meta/meta.dart&#x27;void main() &#123; func1(123); func2(&#x27;222&#x27;); func3(&quot;lecon&quot;);// func3(&quot;lecon&quot;,&quot;spawn&quot;,123); error,使用下边的中括号，注意区别。这个使用key区分，下面使用位置区分 func3(&quot;lecon&quot;,param2:&quot;spawn&quot;,param3:123);// func4(&quot;lecon&quot;,param2:&quot;spawn&quot;); error required func5(&quot;lecon&quot;,&quot;spawn&quot;,&quot;hahaa&quot;); func6(&quot;lecon&quot;,age:25); print(func7());&#125;void func1(param1) &#123; print(param1);&#125;void func2(String param2) &#123; print(param2);&#125;void func3(String param1,&#123;String param2,int param3&#125;) &#123; print(&quot;I am $&#123;param1&#125;, Hi $&#123;param2&#125;,I am $&#123;param3&#125;&quot;);&#125;// test in flutter// void func4(String param1,&#123;String param2,@required int param3&#125;) &#123;// print(&quot;I am $&#123;param1&#125;, Hi $&#123;param2&#125;,I am $&#123;param3&#125;&quot;);// &#125;void func5(String param1,[String param2,String param3]) &#123; print(&quot;I am $&#123;param1&#125;, bian bu $&#123;param2&#125; xia qu le $&#123;param3&#125;&quot;);&#125;// 只有使用&#123;&#125;和[]的才可以有默认值void func6(String param1,&#123;int age = 23&#125;) &#123; print(&quot;I am $&#123;param1&#125;, I am $&#123;age&#125;&quot;);&#125;func7() &#123; void func8() &#123; &#125; void func9() &#123; &#125; retrun () =&gt; &quot;123&quot;;&#125; 流程控制Dart 的流程控制和 java 的用法基本一样,这里就不介绍了。 有个 for in 要说下，和 JavaScript 很像。 1for (var x in collection) &#123;&#125; 相当于 java 的高级 for 循环 1for(Integer i : indexs) &#123;&#125; 面向对象相对于 java 有这几点需要注意 new关键字可以省略 一个类同名构造器只能有一个，也就是说可以给构造器起其他名字。所以可以把构造器分为默认构造器和命名构造器。 命名构造器不能自动继承，参考下面 Dart 使用this代表当前对象 初始化列表 Dart 有继承和接口概念，和 java 基本差不多，同时多了个混入的的概念minix，这个非常好理解。 下面这个例子是类构造器的基本使用 普通构造器和继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Person &#123; String name; int age; String dantengt; // 注意，冒号后边是初始化列表，用，隔开。 Person() :dantengt = &quot;danm&quot;; @override String toString() =&gt; &quot;name : $&#123;name&#125;;age : $&#123;age&#125;&quot;;&#125;class Person2 &#123; String name; int age; // 默认构造器只能声明一个 // 不用写set方法，使用this可以直接把值赋给相应的属性 Person2(this.name,this.age); // 命名构造器 Person2.copy(Person p) &#123; this.name = p.name; this.age = p.age; &#125; @override String toString() =&gt; &quot;name : $&#123;name&#125;;age : $&#123;age&#125;&quot;;&#125;class Student extends Person2 &#123; final String school; // 普通构造器继承 Student(String name,int age,this.school):super(name,age); // 命名构造器的继承 Student.copy(Person p,this.school):super.copy(p); // 类似构造器的重载 Student.mySchoolCopy(Person p):this.copy(p,&#x27;mySchool&#x27;);&#125;// 所有值都不可以改变class ImmutablePoint &#123; static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; // cosnt修饰的构造器是常量构造器，里面的值都不许改变。因为是编译时的。 const ImmutablePoint(this.x, this.y);&#125;void main() &#123; final person = Person(); person.name = &quot;spawn&quot;; person.age = 18; print(person); final person2 = Person2(&quot;lecon&quot;,25); print(person2); print(Person2.copy(person)); Person2 p2 = Student(&quot;lecon&quot;,25,&quot;haha&quot;); // is 和 as ;类似 instanceof和强转 if (p2 is Student) &#123; (p2 as Student).school; &#125;&#125; 其中： Person 类的构造器后面有个：，那个就是初始化列表，可以给属性赋值（参考 Person 类），还可调用父类构造器。 Person2 类有两个构造器，默认构造器没有名字，和 java 中一样使用类名声明。另外还有一个Person2.copy() 他也是一个构造器，只不过它有名字了，同名构造器只能出现一次，不管是不是重载（貌似 Dart 没重载）。 在构造器参数列表中，如果直接使用this关键字，可以直接把值付给类的属性，省去了 set 方法（参考类 Person2 的默认构造器）。 在类中，所有的属性或者方法，只要带了_前缀，那么他就是私有的，Dart 文件之外不能访问，当前文件不同类是可以的。 is关键字相当于instanceof ，as相当于强转。这个和 Kotlin 很像。 const修饰构造器，代表类是编译时的。所有内容不允许改变。 类的继承使用extends关键字，同时 dart 也有接口，和 java 基本一致，不再赘述。 除了继承和接口之外，Dart 还有个mixin混入的概念，可以把他理解为：把其他类的东西，一股脑放到当前类中，使用with关键字描述。 minix关于 minix 参考以下代码： 1234567891011121314151617181920212223242526// class关键字换成minix，其他和class一样，只是换个名字。mixin Play &#123; void play() &#123; print(&quot;I can play&quot;); &#125;&#125;mixin Eat &#123; void eat() &#123; print(&quot;I can eat&quot;); &#125;&#125;// 使用with关键字加入mixin类class Person with Play,Eat &#123; final String name; final int age; Person(this.name,this.age);&#125;void main() &#123; final p = Person(&quot;lecon&quot;,13); // 此时p有了Eat和Play的能力 p.play(); p.eat();&#125; factory 构造器和多态java 编程中，在使用多态的时候，我们可能会用到工厂方法，dart 给我们提供一个方便，使用 dart 的工厂构造器。dart 的工厂构造器也是个构造器，只不过使用 factory 修饰，他返回当前类，并且不能使用 this 关键字，示例代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Person2 &#123; String name; int age; Person2(this.name,this.age); // factory 构造器也是构造器，同样不能声明两个相同名字的，而且只能有一个默认 // factory 没有this引用 factory Person2.select(name,int age,int type) &#123; if(type == 0) &#123; return Student(name,age,&quot;jaja&quot;); &#125; else &#123; return Worker(name,age,&quot;lala&quot;); &#125; &#125; // callable call(String a, String b, String c) =&gt; &#x27;$a $b $c!&#x27;; @override String toString() =&gt; &quot;name : $&#123;name&#125;;age : $&#123;age&#125;&quot;;&#125;class Student extends Person2 &#123; final String school; Student(String name,int age,this.school):super(name,age);&#125;class Worker extends Person2 &#123; final String company; Worker(String name,int age,this.company):super(name,age);&#125;void main() &#123; // 不关注Person2实现类，直接使用Person2实例化。使用factory final p1 = Person2.select(&quot;lecon&quot;,23,0); final p2 = Person2.select(&quot;lecon&quot;,23,1); print(p1.runtimeType); // Student print(p2.runtimeType); // Worker // callable print(p1(&quot;123&quot;,&quot;234&quot;,&quot;345&quot;));&#125; 其中select为 Person2 的工厂构造器，由它来返回对应的实现类。 setter 和 getter很多语言里面，为了方便获取属性都提供了 setter 和 getter。其实他就是个语法糖。直接使用就可以。看例子： 1234567891011121314151617class Rectangle &#123; num left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); num get right =&gt; left + width; set right(num value) =&gt; left = value - width; num get bottom =&gt; top + height; set bottom(num value) =&gt; top = value - height;&#125;void main() &#123; var rect = Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8);&#125; 异常Dart 的异常也和 java 非常像。直接看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void main() &#123;// throw1();// throw2();// throw3();// throw4(); throw5();&#125;void throw1() &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;);&#125;void throw2() &#123; throw &#x27;Expected at least 1 section&#x27;;&#125;void throw3() &#123; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException &#123; print(&#x27;section exception&#x27;); &#125; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException catch(e) &#123; print(&#x27;section exception $&#123;e&#125;&#x27;); &#125; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException catch(e,s) &#123; print(&#x27;section exception $&#123;e&#125;&#x27;); print(s); // 打印方法调用栈 &#125;&#125;void throw4() &#123; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException &#123; print(&#x27;section exception&#x27;); rethrow; // 重抛 &#125;&#125;void throw5() &#123; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException &#123; print(&#x27;section exception&#x27;); &#125; finally &#123; print(&quot;I am finally&quot;); &#125;&#125; dart 可以直接抛出默认异常，throw &#39;Expected at least 1 section&#39;; 使用on来匹配异常类型，on FormatException 使用catch来获取异常变量，catch(e,s)它有一个默认参数和可选参数。分别为信息和调用栈。 使用rethrow重新抛出异常 异步dart 的异步和 JavaScript ES6 差不多，使用await和async，只不过 ES6 中的 Promise 变成了 Future。目前比较流行的解决方案都是这个，比如 Python,Kotlin 都这么使用。一般在网络请求或者数据库操作时候使用，就像 java 的多线程基础版吧。 异步这块东西有点多，而且很重要，直接贴官方地址。https://www.dartlang.org/guides/libraries/library-tour#future 异步中有两个很重要的接口：Future和Stream。贴出地址，这两个一定要弄明白。https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming 生成器Dart 的生成成器和其他语言里面的生成器差不多，分为同步和异步两种。同步生成器结构是Iterable，异步生成器接口是Stream。流程控住使用async*（异步）和sync*（同步）声明，使用yield流程控制，每一次yield都会给列表生成一个值，也就是说生成器返回结果的数据结构可以当列表使用。以下代码： 1234567891011121314151617181920212223242526272829void main() &#123; print(naturalsTo(10)); // (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) print(naturalsDownFrom(10)); // (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) asynchronousNaturalsTo(10) .toList() // toList把异步转为同步 .then((res) &#123; print(res); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &#125;);&#125;// 同步生成器Iterable&lt;int&gt; naturalsTo(int n) sync* &#123; int k = 0; while (k &lt; n) yield k++;&#125;// 异步生成器Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* &#123; int k = 0; while (k &lt; n) yield k++;&#125;// 递归性质的生成器Iterable&lt;int&gt; naturalsDownFrom(int n) sync* &#123; if (n &gt; 0) &#123; yield n; yield* naturalsDownFrom(n - 1); &#125;&#125; 其他import 关键字1234567891011import &#x27;package:lib1/lib1.dart&#x27;;import &#x27;package:lib2/lib2.dart&#x27; as lib2;// 仅导入fooimport &#x27;package:lib1/lib1.dart&#x27; show foo;// 排除fooimport &#x27;package:lib2/lib2.dart&#x27; hide foo;// 异步导入import &#x27;package:greetings/hello.dart&#x27; deferred as hello; 空判断Dart 也有null类型，并且和其他语言类似，Dart 也是用？来解决空问题。 12345678void main() &#123; final a = null; print(a != null ? a : &quot;b&quot;); // 等同于下边,dart也支持三元运算符 print(a ?? &quot;b&quot;); // 打印 b String p = null; print(p?.toString()); //打印null，而不会空指针&#125; ..运算符Dart 的联级运算符..很有意思，很实用的语法糖，直接看代码你就明白了。Builder大法好。 1234567891011121314151617181920212223void main() &#123; // 联级运算符 final p = Person() ..username = &quot;lecon&quot; ..password = &quot;123456&quot; ..setSex(true); print(p); // Username: lecon; Password: 123456; Sex: true&#125;class Person &#123; String _username; String _password; bool _sex; set username(String username) =&gt; this._username = username; set password(String password) =&gt; this._password = password; void setSex(bool sex) =&gt; this._sex = sex; @override String toString() =&gt; &quot;Username: $&#123;this._username&#125;; Password: $&#123;this._password&#125;; Sex: $&#123;this._sex&#125;&quot;;&#125; Typedefs这个和 C++里边的内联函数基本差不多。官方例子 https://www.dartlang.org/guides/language/language-tour#typedefs 注释Dart 注释分为三种，单行注释和多行注释和 java 一致。doc 注释使用 ///表示。 1234/// A domesticated South American camelid (Lama glama).////// Andean cultures have used llamas as meat and pack/// animals since pre-Hispanic times. ##最后临时总结，难免有错误，请多多指出，我会在第一时间改正。 代码地址https://gist.github.com/leconio/73bd75eef9530ff76ac59e09b1331865","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"开启BBR搭建ss-server","slug":"开启BBR搭建ss-server","date":"2019-06-10T21:13:09.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2019/06/10/开启BBR搭建ss-server/","link":"","permalink":"https://leconio.github.io/2019/06/10/%E5%BC%80%E5%90%AFBBR%E6%90%AD%E5%BB%BAss-server/","excerpt":"这次的教程主要分为以下几个部分： 搭建 Shadowsocks-libev 服务端 配置防火墙","text":"这次的教程主要分为以下几个部分： 搭建 Shadowsocks-libev 服务端 配置防火墙 接着上回说，现在我们 ssh 到搬瓦工服务器。 检查 bbr第一件事儿就是检查有没有开启 bbr 内核，bbr 对于 VPS 的提速上一节已经说过了，非常大。 1sysctl net.ipv4.tcp_available_congestion_control 如果显示 1net.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno 代表 bbr 已经开启。如果结果中没有 bbr 也不用担心，我在上一篇文章放出了一个安装 bbr 和锐速的脚本，可以直接使用。 安装 Shadowsocks 服务器前段时间秋大的博客宣布告别，这意味着高质量的一键安装脚本越来越少。虽然搬瓦工提供一件安装选项，但可定制化不高，所以我建议大家使用托管在 github 的原始项目，理由是可以保持功能最新，遇到问题也可以通过 issues 而得到迅速解决，shadowsocks-libev。首先安装依赖项目 12yum install epel-release -yyum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y shadowsocks-libev 托管在 dnf 的 copr 仓库内，默认的 centos7 是不带这个仓库。这里我们安装 dnf 和 copr 仓库。1. 安装 dnf 和 copr 仓库 123yum install dnfdnf install dnf-plugins-corednf install dnf-plugins-copr 2. 开启 copr 的shadowsocks-libev 1dnf copr enable librehat&#x2F;shadowsocks 3. 安装 shadowsocks-libev 12dnf updatednf install shadowsocks-libev 到此为止，如果没有出现什么问题，安装就算完成了，现在执行下面的命令来测试一下： 1ss-server -h 配置服务端参数上面说到，通过执行 ss-server 可以启动一个 ss 服务器，但是，在实际使用的时候，我们通常设置自己使用的参数，下面的例子是一组最简单的参数。 1ss-server -p 8989 -k 123456 -m chacha20 --fast-open 其中-p 是对外开放的端口，-k 是密码，-m 是加密方式，chacha20 是一种非常优秀的加密方式呦，你懂得。–fast-open 开启 TCP 快速打开模式。你可以直接在 VPS 的执行上面的命令，但是这是一个阻塞命令，我们可以使用 nohup 来切换到后台运行。 1nohup ss-server -p 8989 -k 123456 -m chacha20 --fast-open &amp; 看一下我们的 ss-server 是否启动成功 12# 通过pid查看ss是否启动ps -ef|grep ss-server 12# 通过端口查看ss是否启动iptables -xvn -L|grep 8989 别忘了防火墙在上面的参数中，ss 对外开放的端口是 8989。那么我们通过 Centos7 的 firewalld-cmd 防火墙放行这个端口。 123456systemctl enable firewalldfirewall-cmd --set-default-zone&#x3D;publicfirewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;sshfirewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;tcpfirewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;udpfirewall-cmd --reload 上面开启了 ssh 服务使用的端口和 8989 端口，如果你还有需要使用的端口，请参考这篇文章How To Set Up a Firewall Using FirewallD on CentOS 7好啦！测试一下我们的 8989 通不通吧，在本地电脑 telnet 到 8989 1telnet [domain name or ip] 8989 空白代表通了。 （未完待续）下一篇讲述怎么搭建客户端，以及一些小技巧。","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"破解公司 Mac 电脑的 jamf 限制，让 Mac 可以共享 Wifi","slug":"破解公司Mac的Wifi共享限制","date":"2019-06-05T16:49:06.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2019/06/05/破解公司Mac的Wifi共享限制/","link":"","permalink":"https://leconio.github.io/2019/06/05/%E7%A0%B4%E8%A7%A3%E5%85%AC%E5%8F%B8Mac%E7%9A%84Wifi%E5%85%B1%E4%BA%AB%E9%99%90%E5%88%B6/","excerpt":"一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。","text":"一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。 这些功能的限制都是通过 Mac 的 jamf 管理的，破解限制需要 Root 权限。首先我们先找到 jamf 这个可执行文件，他一般在 /usr/local/jamf/ 下面。也可以通过 find 命令查找。 1234567find /usr/local |grep jamf/usr/local/bin/jamf/usr/local/bin/jamfAgent/usr/local/jamf/usr/local/jamf/bin/usr/local/jamf/bin/jamf 我的 jamf 可执行文件在 /usr/local/jamf/bin 下面。那么开始破解： 首先通过执行 1sudo jamf removeMDMProfile 移除 jamf 的限制，这时候受限制的功能就可以使用了。但是，过一段时间之后你会发现又恢复原来的状态了。那么应该怎么解决呢？我们做一个伪装的 jamf 吧！这时候系统调用 jamf 的时候，就会调用我们伪装的文件，不让我们的破解失效。 首先备份原始文件，这里要把整个 bin 目录备份。 123cd /usr/local/jamfmkdir backupmv bin backup 新建一个伪装 jamf 的纯文本文档，输入以下信息 12#!&#x2F;bin&#x2F;shecho &#39;dummy&#39; &gt; &#x2F;dev&#x2F;null 替换原有的 jamf 123mkdir &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;sudo mv jamf &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;chmod +x &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;jamf 然后重启你的 Mac ，大功告成！","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"Centos7增加swap分区大小","slug":"Centos7增加swap分区大小","date":"2018-12-21T13:57:17.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2018/12/21/Centos7增加swap分区大小/","link":"","permalink":"https://leconio.github.io/2018/12/21/Centos7%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/","excerpt":"如何增加 Centos7 的 swap 分区大小","text":"如何增加 Centos7 的 swap 分区大小 1.添加 swap 分区dd if=/dev/zero of=/var/swapfile bs=1024 count=4096k 2.执行完毕，对交换文件格式化并转换为 swap 分区：mkswap /var/swapfile 3.挂载并激活分区：swapon /var/swapfile 4 赋权限chmod -R 0600 /var/swapfile 5.设置开机自动挂载该分区：vi /etc/fstab在 fstab 文件末尾追加如下内容后:wq!保存即可：/var/swapfile swap swap defaults 0 0","categories":[{"name":"黑洞","slug":"黑洞","permalink":"https://leconio.github.io/categories/%E9%BB%91%E6%B4%9E/"}],"tags":[]},{"title":"使用Caddy代理Bitbucket服务器","slug":"使用Caddy代理Bitbucket服务器","date":"2018-12-21T13:55:53.000Z","updated":"2021-03-04T03:51:15.157Z","comments":true,"path":"2018/12/21/使用Caddy代理Bitbucket服务器/","link":"","permalink":"https://leconio.github.io/2018/12/21/%E4%BD%BF%E7%94%A8Caddy%E4%BB%A3%E7%90%86Bitbucket%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。","text":"在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。 BitbucketBitbucket 虽然不是一个免费的版本管理工具，但是本身体验还是很好的，即使付费版本个人使用也很便宜。基于 Java 实现，执行效率当然说的过去。相比于 gitlab 这种需要内存至少 2G 的怪兽，至少是一个选择，而却他不容易宕机，但是他的最大魅力还是配置比较简单。 下载方式，官网找下载链接，直接 wget1https:&#x2F;&#x2F;bitbucket.org&#x2F;product&#x2F;download Caddy使用 Caddy 之前，一直使用 Nginx 作为反向代理服务器，但是 Nginx 配置比较复杂，本身又基于服务模式启动，对于玩家不太友好。Caddy 解决了这些问题，下载好，只需要要执行一个命令就可以启动服务器，全世界都能看到你了。主要是，他可以自动申请 ssl，免去自己申请。 下载方式：1curl https:&#x2F;&#x2F;getcaddy.com | bash -s personal 步骤Atlassian 家的软件启动都非常简单。下载好之后，给它一个可执行的权限，然后./他就可以了。 12chmod +x atlassian-bitbucket-5.16.0-x64.bin.&#x2F;atlassian-bitbucket-5.16.0-x64.bin 这个步骤最好给它 Root 权限。安装完成之后，在/opt下面你可以找到他。到bin目录下，启动它 12cd &#x2F;opt&#x2F;atlassian&#x2F;bitbucket&#x2F;5.16.0&#x2F;bin.&#x2F;start-bitbucket.sh 然后，访问youip:7990。现在大概可以配置这台 git 服务器了。一台电脑只有一个 80 或者 443 端口，不同的服务想使用同一个端口就需要反向代理服务器了。Caddy 需要一个 Caddyfile 文件，可以理解为 Caddy 的描述文件，随便创建一个目录，然后新建这个文件： 123mkdir -p ~&#x2F;wwwcd ~&#x2F;wwwvi Caddyfile 在这个文件中粘贴 123456789git.lecon.io &#123; proxy &#x2F; http:&#x2F;&#x2F;127.0.0.1:7990 &#123; header_upstream Host &#123;host&#125; header_upstream X-Real-IP &#123;remote&#125; header_upstream X-Forwarded-For &#123;remote&#125; header_upstream X-Forwarded-Server &#123;host&#125; header_upstream X-Forwarded-Proto &#123;scheme&#125; &#125;&#125; 意思大概就是说，把客户端的环境信息原封不动的发送给被代理对象。在当前 Caddyfile 目录中执行caddy。输入一下邮箱，现在访问你的网址，可以直接使用了。这个命令会阻塞当前 session，所以最好叫他到后台运行 1nohup caddy &amp; 跨域问题Caddy 会默认把 http 流量转发到 https 上，给客户端发送一个 302，重定向到 https 网址，这样的话就会出现一个问题，我在打开 Bitbucket 网页，然后请求外部网页，就会发生跨域问题，导致 Webhook 功能不能使用。现在需要配置一下 Bitbucket，找到bitbucket.properties 1find &#x2F;|grep bitbucket.properties 然后加入下面内容 12345server.port&#x3D;7990server.secure&#x3D;trueserver.scheme&#x3D;httpsserver.proxy-port&#x3D;443server.proxy-name&#x3D;git.lecon.io 重启一下 Bitbucket 服务器，Webhook 等功能可以正常使用。","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://leconio.github.io/categories/Android/"},{"name":"Go","slug":"Go","permalink":"https://leconio.github.io/categories/Go/"},{"name":"ReactNative","slug":"ReactNative","permalink":"https://leconio.github.io/categories/ReactNative/"},{"name":"玩儿","slug":"玩儿","permalink":"https://leconio.github.io/categories/%E7%8E%A9%E5%84%BF/"},{"name":"黑洞","slug":"黑洞","permalink":"https://leconio.github.io/categories/%E9%BB%91%E6%B4%9E/"}],"tags":[]}