{"meta":{"title":"lecon","subtitle":null,"description":null,"author":"lecon","url":"https://lecon.io","root":"/"},"pages":[],"posts":[{"title":"使用frp访问公司内部网络","slug":"使用frp访问公司内部网络","date":"2021-03-03T21:20:56.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2021/03/03/使用frp访问公司内部网络/","link":"","permalink":"https://lecon.io/2021/03/03/%E4%BD%BF%E7%94%A8frp%E8%AE%BF%E9%97%AE%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C/","excerpt":"观看之前，建议你有 ssh 和简单的 shell 使用经验。","text":"观看之前，建议你有 ssh 和简单的 shell 使用经验。 功能简介 观看之前，建议你有 ssh 和简单的 shell 使用经验。 顾名思义，这是一个通过内网穿透自建 vpn 来访问公司内网的教程。说到内网穿透、vpn 都不是什么新鲜的概念，但是这些工具组合起来确实有很多好玩的地方。在这里，就是他们其中的一种组合游戏。好戏开始之前，我们先提出几个疑问，让我猜猜你想的对不对。 1. 我在家里可以访问公司内网吗，比如打卡，收发邮件之类的？ 2. 我需要哪些必备的东西呢？ 3. frp是个什么工具？那么，带着疑问我们开始吧！ 实现原理frp一句话来说就是，通过 frp 把公司计算机的 ssh 暴露出来，个人计算机使用公司计算机 ssh 的 socks5 代理进行上网。 首先介绍一下 frp 这个软件，经常做微信开发的小伙伴应该有接触到，它是搞内网穿透的。在调试公众号或者小程序接口的时候，需要把开发服务器映射到公网上，这样微信服务器才能成功回调到开发者计算机。但是，我们开发计算机在局域网呀，在使用 NAT 转换之后，公网服务器无法直接访问局域网计算机；也就是说，我可以访问互联网，但是互联网无法主动访问我。frp 就是解决这个问题的，它把我自己的计算机的 web 服务放到公网上，然后我们就可以从互联网访问到它。 那么话说回来了，这和今天这个话题有什么联系呢？我们要让个人计算机使用公司的计算机网络进行网络访问，就必须把公司的计算机暴露在互联网当中。如下图： 其实你已经注意到了：把公司计算机直接暴露在公网，会不会不安全呀？当然会，实际使用过程中，一定要按需开启，并且使用安全验证。 frp 不仅仅能把 web 服务暴露在公网，而且还可以把 ssh 服务暴露在公网上。也就是说，我可以通过个人计算机直接 ssh 公司的内网的计算机。 ssh代理我们使用的是 ssh 的 socks5 代理，ssh 有这样一个功能，就是把 ssh 服务器当成一个 socks5 正向的代理，把监听到 socks5 服务端口的流量转发到 ssh 服务器上。就可以实现个人计算机通过公司内网计算机进行上网了。 下面介绍需要用到的设备以及环境。 原材料上面说到，要想实现必须有三台计算机。首先，公司的个人电脑和家中的电脑是其中两个，还需要一个公网电脑进行数据中转。 流量转发端流量转发端是公网中转计算机，它是什么呢？简言之就是有独立 ip 的服务器，这个很容易就买到了，比如阿里云或者腾讯云什么的，很多小伙伴在双 11 和和双 12，被他们冲了一波业绩吧！现在用起来吧，我这里环境使用 Centos7，使用 Ubuntu 的小伙伴也关系，只是防火墙设置不同而已。 流量提供端流量提供端为公司的计算机，必须支持 ssh 服务，Linux 和 Mac 原生支持了，Windows 需要额外下载软件进行支持，比如 Windows10 的内置 Ubuntu，我这里使用 Mac 系统。 流量消费端流量消费端为个人计算机，可以是 Mac、Linux，或者 Windows，Android，后两个需要额外软件，iOS 没有试过。我这里使用 Mac 系统。 我个人不建议使用 Windows 最为搭建这套环境，Windows 下的 Linux 子环境实在是难以折腾，即使通过虚拟机或者 bash 等折腾成功，还要考虑网络问题。 搭建过程搭建过程分为以下几步。 1. 在中转服务器和公司计算机之间搭建frp服务。 2. 个人计算机可以通过ssh访问公司计算机。 3. 把个人计算机的ssh流量作为局部代理 4. 设置局部代理这样一来工作就清晰了起来！ 1. 搭建 frp 服务frp 分为客户端和服务端两个软件，我们可以从 https://github.com/fatedier/frp/releases 获得（他们在同一个压缩内）。其中 frps 是服务器端，frpc 是客户端。把 frps 放到中转服务器，把 frpc 放到公司计算机。 同时，不管设计 frps 还是 frpc，都仅仅需要一个软件和一个配置文件即可运行。 搭建中转服务器的 frps 服务（操作中转服务器）这一步的目的是建立 frp 服务器。首先 ssh 到中转服务器，下载 frp 软件 12wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.23.2&#x2F;frp_0.23.2_linux_amd64.tar.gztar -zxvf frp_0.23.2_linux_amd64.tar.gz 得到解压的文件，我们只需关注 frps 和 frps.ini 这两个，其他的可以删除。编辑 frps.ini 12[common]bind_port &#x3D; 7000 然后运行 frp 服务端。 1.&#x2F;frpc -c .&#x2F;frpc.ini 当然，为了方便使用，也可以后台运行。 1nohup .&#x2F;frpc -c .&#x2F;frpc.ini &amp; 搭建公司计算机的 frpc 服务（操作公司计算机）这一步要打通公司计算机和中转服务器之间的连接。在这之前，首先要确定公司的计算机时候开启 ssh 服务器。Linux 默认都会开启，Windows 用户只能去找软件来使用，其中 Bitvise SSH Server 还不错，使用起来也比较简单，只是收费。Mac 系统参考如下： 系统偏好设置 -&gt; 共享 -&gt; 远程登录。勾选上，然后在右边添加自己用户。设置好 ssh 服务之后，请下载 frp 客户端软件。这里需要 frpc 和 frpc.ini 这两个文件，其他都可以删除掉。 下载时候要选择好对应平台再下载。客户端和服务端如果系统平台不一样，就不能用同一份（虽然客户端和服务端在同一个文件夹中）。 然后编辑 fric.ini 123456789[common]server_addr &#x3D; x.x.x.xserver_port &#x3D; 7000[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000 注意，这里虽说是在设置公司计算机的客户端配置，但是涉及的到两个端口7000和6000，在中转服务器中也需要添加防火墙例外规则，腾讯云或则阿里云好像还要添加安全组。 其中，x.x.x.x为你中转服务器的公网 ip。server_port是中转服务器和公司服务器通信的端口，remote_port是 ssh 的虚拟端口，我们连接时候指定的端口就是它。其他的参数都无关紧要，具体可以了解 https://github.com/fatedier/frp 。 现在启动公司计算机的 frp 客户端 1.&#x2F;frpc -c .&#x2F;frpc.ini 到这里，主要工作基本上已经完成了，现在就来测试一下是否可以从个人计算机通过 ssh 连接到公司的计算机吧。 2. SSH 到公司计算机（操作个人计算机）如果使用的是 mac 或者 linux 可以直接使用下面的命令，连接到公司计算机。如果是 windows，需要下载 putty 或者 linux 子系统等 ssh 软件（后文提到）。 1ssh -oPort&#x3D;6000 [用户名]@x.x.x.x 其中，x.x.x.x 是你中转服务器的公网 ip。注意这里一定要加上面指定的端口，不然会连接到中转服务器的 ssh 服务。不出什么问题，就可以连接到公司计算机了。 在这个过程中，如果很久都没连接上，或者被远程主动关闭，请检查防火墙的设置。我们可以使用 telnet 命令测试远程端口是否开启。 教程到这里，好像和 vpn 好像还没有什么太大的关系，仅仅是可以控制公司的计算机而已。不要忘记，ssh 有一个很好的功能，就是把远程服务器的流量，变成本地计算机的 socks5 代理。 3. 设置 ssh 的 socks5 代理（操作个人计算机）好的，现在可以按 control+c 停止连接。然后，Linux 用户和 Mac 用户可以直接输入以下命令直接开启 sock5 隧道。 1ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 [公司计算机账户]@[中转服务里ip] 比如 1ssh -f -N -D 127.0.0.1:1080 -oPort&#x3D;6000 spawn@192.168.2.1 注意以上命令，这里又多出一个 1080 的端口，这个端口是为本地开的。任何把代理端口指向这个位置的连接，都可以使用这个代理，所以这里要记住这个端口。 如果你想让局域网其他电脑也可以访问，那么把 127.0.0.1 换成 0.0.0.0。 注意：ssh 的 sock5 代理如果长时间不使用会自动断开连接，当然，使用autossh可以解决这个问题。 Windows 用户需要额外的软件，推荐使用 putty。操作步骤如下：打开 putty其中 x.x.x.x 为中转服务 ip，端口填写 6000 按照上图操作步骤操作然后检查路由表，看看是否正常开启。 1netstat -n -a 到此 Windows 可以开启一个端口为 1080 的 sock5 隧道开启 sock5 隧道之后，怎么能检测一下呢？打开一个新的 Shell，输入 12export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080curl cip.cc 注意，上面的 1080 就是之前预留的端口，地址 127.0.0.1 指向本地。接下来使用上面命令看一看公网 ip 是不是和公司计算机的一样。（PS. 公司计算机也可以输入这个命令查看，或者直接百度关键字 ip。如果相同，那么以上过程就全部成功了！ 插个题外话，如果把公司计算机去掉，直接连接中转服务器的 ssh 服务的话，你懂得~。ssh 比 pptp 和 l2tp 要爽哦，关键日子那几天，纸飞机隧道都不可用，全靠它呢！！！ 接下来，有了 sock5 代理，按理说文章应该可以结束了。但是毕竟还没有看到效果，那么接下来简单说说它的几种食用方式，这个过程可以任意发挥，没有固定方式！ 通过局部代理上网上面我们说到，如何把 ssh 流量变成 socks5 局部代理，那么现在就是怎么使用这个局部代理了。 命令行代理这种代理方式只在当前 session 生效，一旦关闭当前命令行，就会失效。 123开启方式 export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080关闭方式 export ALL_PROXY&#x3D;检验方式 curl cip.cc Mac 全局代理系统偏好设置 -&gt; 网络 -&gt; 高级 -&gt; 代理 -&gt; socks 代理 勾选这个点击确定。 Chrome 插件分网址代理推荐使用插件 SwitchyOmega，由于本教程不是讲局部代理使用方式，直接贴这个插件的使用教程 https://github.com/FelisCatus/SwitchyOmega 。使用SwitchyOmega可以针对不同网页使用不同的代理方式，比如说，1080 端口是访问公司内网的，1088 端口是土啬的。它还可以破除公司对于某些网站的限制，同时也代理就不用切来切去了，十分方便。 Proxifier 分应用代理使用 SwitchyOmega 可以在访问不同网站的时候使用不同的代理设置，那么 Proxifier 就可以针对于不同的应用使用不同的代理，甚至切断互联网连接。或者我们可以把上面教程反过来玩，然公司服务器当个人计算机，家中的电脑扮演公司计算机的角色。使某些 App 走家中的流量，就可以简单破除公司对于某些 App 的网路限制，比如微信或者音乐视频类软件，但是要注意 dns 的设置。 它是一个十分优秀的软件，但是需要付费。如果是针对外企用户需要频繁切换网络的用户来说，它的确是一个福音。 注意事项一般来说，公司的网络安全部都不会允许把公司计算机暴露在公网之下，本文只讨论技术，大家好好玩儿~ 2021 年 3 月 2 日更新使用nps后者goproxy过程会更简单 - -","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"Android的Binder的调用方面","slug":"Android的Binder的调用方面","date":"2021-03-03T21:07:07.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2021/03/03/Android的Binder的调用方面/","link":"","permalink":"https://lecon.io/2021/03/03/Android%E7%9A%84Binder%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2/","excerpt":"Android 的 Binder 的调用方面","text":"Android 的 Binder 的调用方面 调用从 Binder 的远程方法调用来看，Proxy 是调用端，Stub 是被调用端。由 AIDL 的 Interface 实现类，可以看出： 123456789101112131415161718public java.util.List&lt;com.leconio.aidlsender.Person&gt; getPersons() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.leconio.aidlsender.Person&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getPersons, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; return getDefaultImpl().getPersons(); &#125; _reply.readException(); _result = _reply.createTypedArrayList(com.leconio.aidlsender.Person.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; 先获取两个 Parcel，一个用于传递数据，一个用于接收数据。每个 Parcel 中都有一个mNativePtr，是个 long 类型，其实他是 JNI 中的 Parcel，由 reinterpret_cast 转换而来。也就是说，Java 层的 Parcel 包裹着 JNI 层的 Parcel。Parcel 是在一个 Parcel 池中获取，这个池大小是 6。mNativePtr 会在 CPP 代码中 Parcel 初始化的时候被初始化。 123456static jlong android_os_Parcel_create(JNIEnv* env, jclass clazz)&#123; sp&lt;ParcelRef&gt; parcelRef = ParcelRef::create(); parcelRef-&gt;incStrong(reinterpret_cast&lt;const void*&gt;(android_os_Parcel_create)); return reinterpret_cast&lt;jlong&gt;(static_cast&lt;Parcel *&gt;(parcelRef.get()));&#125; 上面代码中mRemote的实现类是 Java 层的ProxyBinder，这个地方就调用到了 ProxyBinder 中的transact。 12345678910111213141516public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; ... try &#123; return transactNative(code, data, reply, flags); &#125; finally &#123; AppOpsManager.resumeNotedAppOpsCollection(prevCollection); if (transactListener != null) &#123; transactListener.onTransactEnded(session); &#125; if (tracingEnabled) &#123; Trace.traceEnd(Trace.TRACE_TAG_ALWAYS); &#125; &#125;&#125; 调用到了 cpp 层的transactNative 1234567891011// android_os_BinderProxystatic jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jboolean replyObjOwnsNativeParcel, jint flags) // throws RemoteException&#123; ... IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); // 获取BPBinder ... status_t err = target-&gt;transact(code, *data, reply, flags); // 由BPBinder再次传递 ...&#125; 12345678// BpBinder.cppstatus_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); // 由IPCThreadState传递给驱动&#125; 如果有 reply 的话 12345678910111213// BpBinder.cppstatus_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; ... if (reply) &#123; err = waitForResponse(reply); // 等待回复 &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; ...&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// IPCThreadState.cppstatus_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; // 无限循环等待结果 if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Processing waitForResponse Command: &quot; &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; switch (cmd) &#123; ... case BR_REPLY: // 如果返回消息 &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer); // 设置返回值 &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); &#125; &#125; else &#123; freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); continue; &#125; &#125; goto finish; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125;&#125; 上面的 reply 是 Parcel。我们看看Parcel::ipcSetDataReference。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Parcel.cppvoid Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const binder_size_t* objects, size_t objectsCount, release_func relFunc)&#123; freeData(); mData = const_cast&lt;uint8_t*&gt;(data); // 设置值 mDataSize = mDataCapacity = dataSize; mObjects = const_cast&lt;binder_size_t*&gt;(objects); mObjectsSize = mObjectsCapacity = objectsCount; mOwner = relFunc; binder_size_t minOffset = 0; for (size_t i = 0; i &lt; mObjectsSize; i++) &#123; binder_size_t offset = mObjects[i]; if (offset &lt; minOffset) &#123; ALOGE(&quot;%s: bad object offset %&quot; PRIu64 &quot; &lt; %&quot; PRIu64 &quot;\\n&quot;, __func__, (uint64_t)offset, (uint64_t)minOffset); mObjectsSize = 0; break; &#125; const flat_binder_object* flat = reinterpret_cast&lt;const flat_binder_object*&gt;(mData + offset); uint32_t type = flat-&gt;hdr.type; if (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE || type == BINDER_TYPE_FD)) &#123; // We should never receive other types (eg BINDER_TYPE_FDA) as long as we don&#x27;t support // them in libbinder. If we do receive them, it probably means a kernel bug; try to // recover gracefully by clearing out the objects, and releasing the objects we do // know about. android_errorWriteLog(0x534e4554, &quot;135930648&quot;); ALOGE(&quot;%s: unsupported type object (%&quot; PRIu32 &quot;) at offset %&quot; PRIu64 &quot;\\n&quot;, __func__, type, (uint64_t)offset); releaseObjects(); mObjectsSize = 0; break; &#125; minOffset = offset + sizeof(flat_binder_object); &#125; scanForFds();&#125; 上面代码中，设置了返回值 mData。","categories":[{"name":"黑洞","slug":"黑洞","permalink":"https://lecon.io/categories/%E9%BB%91%E6%B4%9E/"}],"tags":[]},{"title":"Dart对比java快速入门","slug":"Dart对比java快速入门","date":"2020-03-03T21:38:18.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2020/03/03/Dart对比java快速入门/","link":"","permalink":"https://lecon.io/2020/03/03/Dart%E5%AF%B9%E6%AF%94java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"首先本文是通过对比其他语言（主要是 java）快速入门","text":"首先本文是通过对比其他语言（主要是 java）快速入门 定位首先本文是通过对比其他语言（主要是 java）快速入门，建议您至少要熟悉一门静态语言或者动态语言。Dart 和 java 以及 C#都差不多，基本上不用学习可以直接使用，从这里可以你可以了解 Dart 有些特别之处。 首先从一段代码入门吧： 123456789void main() &#123; for (int i = 0; i &lt; 5; i++) &#123; printTest(&#x27;hello $&#123;i + 1&#125;&#x27;); &#125;&#125;void printTest(String variableInteger) &#123; print(variableInteger);&#125; 从上面可以看到，Dart 语言主入口是main函数，他可以不用属于某个类。一眼看上去和 java 差不多。流程控制也是由小括号和大括号构成，不用考虑缩进。结尾必须要加上分号。 声明数据类型12345678void main() &#123; int l = 4; String str1 = &quot;str1&quot;; var i = 1; dynamic d = 0; final j = 2; const k = 3;&#125; Dart 是强类型语言，变量都会有一个类型。你可以向 java 那样直接声明类型，同样可以像 swift 或者 Kotlin 那样使用类型推导。Dart 的类型推导使用 final,var,const,dynamic 关键字。 var修饰变量，这个没什么好说的。 final表示不可变的，修饰内置数据类型，值不可变；修饰对象表示引用不可变，使用到的频率很高。 const是编译时常量，他表示始终不可变，无论修饰内置类型还是对象，或者是数据结构。 dynamic是任意类型，有点像 java 里面的Object，Kotlin 中的Any。 使用 const 修饰的都是编译时常量。它区别于运行时，它的值是不可变的。所有的数据类型，不管是 int 还是 String，初始值都是null 数据类型numbers、strings 和 booleans首先是numbers,strings,booleans其中 numbers 包括int和double类型，分别表示整数和浮点数。strings 就是String类型，普通的字符串。booleans 类型是bool只包含true和false。 numbers * int * double strings * String booleans * bool如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142void main() &#123; // numbers int i = 1; double d = 1.1; // 字符串转数字 // 这里就使用了类型推导 final p1 = &quot;3&quot;; final p2 = &quot;3.3&quot;; print(int.parse(p1)); print(double.parse(p2)); // string // 可以使用（&#x27;xxx&#x27;）（&quot;xxx&quot;）（&#x27;&#x27;&#x27;xxx&#x27;&#x27;&#x27;） 三种方式初始化字符串，和Kotlin很像。 // 字符串比较的是值 final str1 = &quot;test&quot;; final str2 = &quot;test&quot;; print(str1 == str2); // true final str3 = &#x27;test&#x27;; print(str3); final str4 = &#x27;&#x27;&#x27;test&#x27;&#x27;&#x27;; print(str4); print(str4 == str3); // true print(&quot;I&#x27;m $&#123;str4&#125;!!!&quot;); //booleans // null 可以直接用来判断，它是false if(null) &#123; print(&#x27;null is true&#x27;); &#125; else &#123; print(&#x27;null is false&#x27;); &#125; print(&#x27;&#x27;.isEmpty);// final list = [];// if(!list) &#123;// print(&#x27;not empty&#x27;);// &#125;&#125; Dart 的数据结构包括 list 和 map listlist对应的就是 java 里面的 List，list 可以像 Python 等语言那样使用[]进行数组操作，参照以下示例代码。List 有几个在 flutter 非常常用的初始化方式，分别为filled和generate。具体参考：https://api.dartlang.org/stable/2.1.0/dart-core/List-class.html 12345678910111213141516171819202122232425262728293031void main() &#123; // 初始化 final list1 = [1,2,3,4,5]; // 编译时常量 final list2 = const [2,3,4,5,6];// list2[2] = 8; error print(list2); // 初始化2 List&lt;int&gt; list3 = new List(5); print(list3); // [null, null, null, null, null] // 初始化3 filled 第一个参数是个数，第二个是添加的值 List&lt;int&gt; list4 = List.filled(3,10); print(list4); // [10,10,10] // 初始化4 类似Python的Map生成 List&lt;int&gt; list5 = List.generate(3,(i) =&gt; i * 3); print(list5); // [0, 3, 6] // 更改 使用list1 list1[2] = 8; print(list1); // [1, 2, 8, 4, 5] // 添加 list1.add(10);// list1[10] = 20; Index out of range print(list1); // [1, 2, 8, 4, 5, 10] //删除 list1.remove(10); print(list1); // [1, 2, 8, 4, 5]&#125; mapmap 对应 java 里面的 Map，他的操作方式有点像 Python。需要注意的有几点。 Map 的 Key 不能有重复的 如果使用 int 类型作为 key，取值的时候优先使用 key 匹配，然后是下标。 取不到值不会抛异常，直接返回 null Map 和 List 可以转换为 Json,来回转换时深拷贝。 其他 API 参考：https://api.dartlang.org/stable/2.1.0/dart-core/Map-class.html 123456789101112131415161718192021222324252627282930313233343536373839404142import &#x27;dart:convert&#x27;;void main() &#123; final map1 = &#123; &quot;test1key&quot; : &quot;test1value&quot;,// &quot;test1key&quot; : &quot;test1value&quot;, Key 不能相同 123 : &quot;123value&quot;, null : &#x27;NULL&#x27;, 2 : &#x27;2&#x27; &#125;; print(map1); // &#123;test1key: test1value, 123: 123value, null: NULL, 2: 2&#125; // 获取值 print(map1[123]); // key取值 123value print(map1[1]); // 下标取值 null print(map1[2]); // 同时存在时候，优先Key取值；结果为 2 // 追加值 map1[&#x27;appendKey&#x27;] = &#x27;appendVal&#x27;; print(map1); // 更改值 map1[&#x27;appendKey&#x27;] = &#x27;appendVal123&#x27;; print(map1); map1[&#x27;appendKey&#x27;] = null; print(map1); // 置为null之后，key不会消失 map1.remove(&#x27;appendKey&#x27;); // 删除 print(map1); print(map1[&#x27;non-key&#x27;]); // 不会报错 打印 null print(map1.length); // 长度 4 // json 转换 // 使用const修饰的数据结构，不可改变。 final map2 = const &#123; &quot;name&quot;:&quot;lecon&quot;, &quot;age&quot;:23, &quot;ss&quot;:[1,2,3,4,4] &#125;; final jsonText = jsonEncode(map2); print(jsonText); // &#123;&quot;name&quot;:&quot;lecon&quot;,&quot;age&quot;:23,&quot;ss&quot;:[1,2,3,4,4]&#125; final mapObj = jsonDecode(jsonText); print(mapObj); // &#123;name: lecon, age: 23, ss: [1, 2, 3, 4, 4]&#125;&#125; Runes这东西其实就是字符集的扩编，可以用它显示一些表情符号 12345678910main() &#123; var clapping = &#x27;\\u&#123;1f44f&#125;&#x27;; print(clapping); print(clapping.codeUnits); print(clapping.runes.toList()); Runes input = new Runes( &#x27;\\u2665 \\u&#123;1f605&#125; \\u&#123;1f60e&#125; \\u&#123;1f47b&#125; \\u&#123;1f596&#125; \\u&#123;1f44d&#125;&#x27;); print(new String.fromCharCodes(input));&#125; 函数Dart 的函数比 java 多了几个概念。比如在参数列表里面添加个大括号，是可选命名参数；加个中括号叫可选位置参数。 可选命名参数类似 Python 里面的**kwargs，参考下面示例代码func3； 可选位置参数类似 Python 里面的*args，参考下面func5。 可选命名参数和可选位置参数可以有默认值，普通参数不能有，参考func6。 函数之间可以互相嵌套，互相调用，但他们都有自己作用域。 若果函数简单可以使用()=&gt; value简写。 比如 123String test() &#123; return &quot;123&quot;;&#125; 简写成 1String test ()=&gt; &quot;123&quot;; 下面是示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// import &#x27;package:meta/meta.dart&#x27;void main() &#123; func1(123); func2(&#x27;222&#x27;); func3(&quot;lecon&quot;);// func3(&quot;lecon&quot;,&quot;spawn&quot;,123); error,使用下边的中括号，注意区别。这个使用key区分，下面使用位置区分 func3(&quot;lecon&quot;,param2:&quot;spawn&quot;,param3:123);// func4(&quot;lecon&quot;,param2:&quot;spawn&quot;); error required func5(&quot;lecon&quot;,&quot;spawn&quot;,&quot;hahaa&quot;); func6(&quot;lecon&quot;,age:25); print(func7());&#125;void func1(param1) &#123; print(param1);&#125;void func2(String param2) &#123; print(param2);&#125;void func3(String param1,&#123;String param2,int param3&#125;) &#123; print(&quot;I am $&#123;param1&#125;, Hi $&#123;param2&#125;,I am $&#123;param3&#125;&quot;);&#125;// test in flutter// void func4(String param1,&#123;String param2,@required int param3&#125;) &#123;// print(&quot;I am $&#123;param1&#125;, Hi $&#123;param2&#125;,I am $&#123;param3&#125;&quot;);// &#125;void func5(String param1,[String param2,String param3]) &#123; print(&quot;I am $&#123;param1&#125;, bian bu $&#123;param2&#125; xia qu le $&#123;param3&#125;&quot;);&#125;// 只有使用&#123;&#125;和[]的才可以有默认值void func6(String param1,&#123;int age = 23&#125;) &#123; print(&quot;I am $&#123;param1&#125;, I am $&#123;age&#125;&quot;);&#125;func7() &#123; void func8() &#123; &#125; void func9() &#123; &#125; retrun () =&gt; &quot;123&quot;;&#125; 流程控制Dart 的流程控制和 java 的用法基本一样,这里就不介绍了。 有个 for in 要说下，和 JavaScript 很像。 1for (var x in collection) &#123;&#125; 相当于 java 的高级 for 循环 1for(Integer i : indexs) &#123;&#125; 面向对象相对于 java 有这几点需要注意 new关键字可以省略 一个类同名构造器只能有一个，也就是说可以给构造器起其他名字。所以可以把构造器分为默认构造器和命名构造器。 命名构造器不能自动继承，参考下面 Dart 使用this代表当前对象 初始化列表 Dart 有继承和接口概念，和 java 基本差不多，同时多了个混入的的概念minix，这个非常好理解。 下面这个例子是类构造器的基本使用 普通构造器和继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Person &#123; String name; int age; String dantengt; // 注意，冒号后边是初始化列表，用，隔开。 Person() :dantengt = &quot;danm&quot;; @override String toString() =&gt; &quot;name : $&#123;name&#125;;age : $&#123;age&#125;&quot;;&#125;class Person2 &#123; String name; int age; // 默认构造器只能声明一个 // 不用写set方法，使用this可以直接把值赋给相应的属性 Person2(this.name,this.age); // 命名构造器 Person2.copy(Person p) &#123; this.name = p.name; this.age = p.age; &#125; @override String toString() =&gt; &quot;name : $&#123;name&#125;;age : $&#123;age&#125;&quot;;&#125;class Student extends Person2 &#123; final String school; // 普通构造器继承 Student(String name,int age,this.school):super(name,age); // 命名构造器的继承 Student.copy(Person p,this.school):super.copy(p); // 类似构造器的重载 Student.mySchoolCopy(Person p):this.copy(p,&#x27;mySchool&#x27;);&#125;// 所有值都不可以改变class ImmutablePoint &#123; static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; // cosnt修饰的构造器是常量构造器，里面的值都不许改变。因为是编译时的。 const ImmutablePoint(this.x, this.y);&#125;void main() &#123; final person = Person(); person.name = &quot;spawn&quot;; person.age = 18; print(person); final person2 = Person2(&quot;lecon&quot;,25); print(person2); print(Person2.copy(person)); Person2 p2 = Student(&quot;lecon&quot;,25,&quot;haha&quot;); // is 和 as ;类似 instanceof和强转 if (p2 is Student) &#123; (p2 as Student).school; &#125;&#125; 其中： Person 类的构造器后面有个：，那个就是初始化列表，可以给属性赋值（参考 Person 类），还可调用父类构造器。 Person2 类有两个构造器，默认构造器没有名字，和 java 中一样使用类名声明。另外还有一个Person2.copy() 他也是一个构造器，只不过它有名字了，同名构造器只能出现一次，不管是不是重载（貌似 Dart 没重载）。 在构造器参数列表中，如果直接使用this关键字，可以直接把值付给类的属性，省去了 set 方法（参考类 Person2 的默认构造器）。 在类中，所有的属性或者方法，只要带了_前缀，那么他就是私有的，Dart 文件之外不能访问，当前文件不同类是可以的。 is关键字相当于instanceof ，as相当于强转。这个和 Kotlin 很像。 const修饰构造器，代表类是编译时的。所有内容不允许改变。 类的继承使用extends关键字，同时 dart 也有接口，和 java 基本一致，不再赘述。 除了继承和接口之外，Dart 还有个mixin混入的概念，可以把他理解为：把其他类的东西，一股脑放到当前类中，使用with关键字描述。 minix关于 minix 参考以下代码： 1234567891011121314151617181920212223242526// class关键字换成minix，其他和class一样，只是换个名字。mixin Play &#123; void play() &#123; print(&quot;I can play&quot;); &#125;&#125;mixin Eat &#123; void eat() &#123; print(&quot;I can eat&quot;); &#125;&#125;// 使用with关键字加入mixin类class Person with Play,Eat &#123; final String name; final int age; Person(this.name,this.age);&#125;void main() &#123; final p = Person(&quot;lecon&quot;,13); // 此时p有了Eat和Play的能力 p.play(); p.eat();&#125; factory 构造器和多态java 编程中，在使用多态的时候，我们可能会用到工厂方法，dart 给我们提供一个方便，使用 dart 的工厂构造器。dart 的工厂构造器也是个构造器，只不过使用 factory 修饰，他返回当前类，并且不能使用 this 关键字，示例代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Person2 &#123; String name; int age; Person2(this.name,this.age); // factory 构造器也是构造器，同样不能声明两个相同名字的，而且只能有一个默认 // factory 没有this引用 factory Person2.select(name,int age,int type) &#123; if(type == 0) &#123; return Student(name,age,&quot;jaja&quot;); &#125; else &#123; return Worker(name,age,&quot;lala&quot;); &#125; &#125; // callable call(String a, String b, String c) =&gt; &#x27;$a $b $c!&#x27;; @override String toString() =&gt; &quot;name : $&#123;name&#125;;age : $&#123;age&#125;&quot;;&#125;class Student extends Person2 &#123; final String school; Student(String name,int age,this.school):super(name,age);&#125;class Worker extends Person2 &#123; final String company; Worker(String name,int age,this.company):super(name,age);&#125;void main() &#123; // 不关注Person2实现类，直接使用Person2实例化。使用factory final p1 = Person2.select(&quot;lecon&quot;,23,0); final p2 = Person2.select(&quot;lecon&quot;,23,1); print(p1.runtimeType); // Student print(p2.runtimeType); // Worker // callable print(p1(&quot;123&quot;,&quot;234&quot;,&quot;345&quot;));&#125; 其中select为 Person2 的工厂构造器，由它来返回对应的实现类。 setter 和 getter很多语言里面，为了方便获取属性都提供了 setter 和 getter。其实他就是个语法糖。直接使用就可以。看例子： 1234567891011121314151617class Rectangle &#123; num left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); num get right =&gt; left + width; set right(num value) =&gt; left = value - width; num get bottom =&gt; top + height; set bottom(num value) =&gt; top = value - height;&#125;void main() &#123; var rect = Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8);&#125; 异常Dart 的异常也和 java 非常像。直接看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void main() &#123;// throw1();// throw2();// throw3();// throw4(); throw5();&#125;void throw1() &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;);&#125;void throw2() &#123; throw &#x27;Expected at least 1 section&#x27;;&#125;void throw3() &#123; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException &#123; print(&#x27;section exception&#x27;); &#125; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException catch(e) &#123; print(&#x27;section exception $&#123;e&#125;&#x27;); &#125; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException catch(e,s) &#123; print(&#x27;section exception $&#123;e&#125;&#x27;); print(s); // 打印方法调用栈 &#125;&#125;void throw4() &#123; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException &#123; print(&#x27;section exception&#x27;); rethrow; // 重抛 &#125;&#125;void throw5() &#123; try &#123; throw FormatException(&#x27;Expected at least 1 section&#x27;); &#125; on FormatException &#123; print(&#x27;section exception&#x27;); &#125; finally &#123; print(&quot;I am finally&quot;); &#125;&#125; dart 可以直接抛出默认异常，throw &#39;Expected at least 1 section&#39;; 使用on来匹配异常类型，on FormatException 使用catch来获取异常变量，catch(e,s)它有一个默认参数和可选参数。分别为信息和调用栈。 使用rethrow重新抛出异常 异步dart 的异步和 JavaScript ES6 差不多，使用await和async，只不过 ES6 中的 Promise 变成了 Future。目前比较流行的解决方案都是这个，比如 Python,Kotlin 都这么使用。一般在网络请求或者数据库操作时候使用，就像 java 的多线程基础版吧。 异步这块东西有点多，而且很重要，直接贴官方地址。https://www.dartlang.org/guides/libraries/library-tour#future 异步中有两个很重要的接口：Future和Stream。贴出地址，这两个一定要弄明白。https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming 生成器Dart 的生成成器和其他语言里面的生成器差不多，分为同步和异步两种。同步生成器结构是Iterable，异步生成器接口是Stream。流程控住使用async*（异步）和sync*（同步）声明，使用yield流程控制，每一次yield都会给列表生成一个值，也就是说生成器返回结果的数据结构可以当列表使用。以下代码： 1234567891011121314151617181920212223242526272829void main() &#123; print(naturalsTo(10)); // (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) print(naturalsDownFrom(10)); // (10, 9, 8, 7, 6, 5, 4, 3, 2, 1) asynchronousNaturalsTo(10) .toList() // toList把异步转为同步 .then((res) &#123; print(res); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &#125;);&#125;// 同步生成器Iterable&lt;int&gt; naturalsTo(int n) sync* &#123; int k = 0; while (k &lt; n) yield k++;&#125;// 异步生成器Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* &#123; int k = 0; while (k &lt; n) yield k++;&#125;// 递归性质的生成器Iterable&lt;int&gt; naturalsDownFrom(int n) sync* &#123; if (n &gt; 0) &#123; yield n; yield* naturalsDownFrom(n - 1); &#125;&#125; 其他import 关键字1234567891011import &#x27;package:lib1/lib1.dart&#x27;;import &#x27;package:lib2/lib2.dart&#x27; as lib2;// 仅导入fooimport &#x27;package:lib1/lib1.dart&#x27; show foo;// 排除fooimport &#x27;package:lib2/lib2.dart&#x27; hide foo;// 异步导入import &#x27;package:greetings/hello.dart&#x27; deferred as hello; 空判断Dart 也有null类型，并且和其他语言类似，Dart 也是用？来解决空问题。 12345678void main() &#123; final a = null; print(a != null ? a : &quot;b&quot;); // 等同于下边,dart也支持三元运算符 print(a ?? &quot;b&quot;); // 打印 b String p = null; print(p?.toString()); //打印null，而不会空指针&#125; ..运算符Dart 的联级运算符..很有意思，很实用的语法糖，直接看代码你就明白了。Builder大法好。 1234567891011121314151617181920212223void main() &#123; // 联级运算符 final p = Person() ..username = &quot;lecon&quot; ..password = &quot;123456&quot; ..setSex(true); print(p); // Username: lecon; Password: 123456; Sex: true&#125;class Person &#123; String _username; String _password; bool _sex; set username(String username) =&gt; this._username = username; set password(String password) =&gt; this._password = password; void setSex(bool sex) =&gt; this._sex = sex; @override String toString() =&gt; &quot;Username: $&#123;this._username&#125;; Password: $&#123;this._password&#125;; Sex: $&#123;this._sex&#125;&quot;;&#125; Typedefs这个和 C++里边的内联函数基本差不多。官方例子 https://www.dartlang.org/guides/language/language-tour#typedefs 注释Dart 注释分为三种，单行注释和多行注释和 java 一致。doc 注释使用 ///表示。 1234/// A domesticated South American camelid (Lama glama).////// Andean cultures have used llamas as meat and pack/// animals since pre-Hispanic times. ##最后临时总结，难免有错误，请多多指出，我会在第一时间改正。 代码地址https://gist.github.com/leconio/73bd75eef9530ff76ac59e09b1331865","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"Shadowsocks 实战教程全景实录（2）","slug":"Shadowsocks 实战教程全景实录（2）","date":"2019-06-10T21:13:09.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2019/06/10/Shadowsocks 实战教程全景实录（2）/","link":"","permalink":"https://lecon.io/2019/06/10/Shadowsocks%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%E5%85%A8%E6%99%AF%E5%AE%9E%E5%BD%95%EF%BC%882%EF%BC%89/","excerpt":"这次的教程主要分为以下几个部分： 搭建 Shadowsocks-libev 服务端 配置防火墙","text":"这次的教程主要分为以下几个部分： 搭建 Shadowsocks-libev 服务端 配置防火墙 接着上回说，现在我们 ssh 到搬瓦工服务器。 检查 bbr第一件事儿就是检查有没有开启 bbr 内核，bbr 对于 VPS 的提速上一节已经说过了，非常大。 1sysctl net.ipv4.tcp_available_congestion_control 如果显示 1net.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno 代表 bbr 已经开启。如果结果中没有 bbr 也不用担心，我在上一篇文章放出了一个安装 bbr 和锐速的脚本，可以直接使用。 安装 Shadowsocks 服务器前段时间秋大的博客宣布告别，这意味着高质量的一键安装脚本越来越少。虽然搬瓦工提供一件安装选项，但可定制化不高，所以我建议大家使用托管在 github 的原始项目，理由是可以保持功能最新，遇到问题也可以通过 issues 而得到迅速解决，shadowsocks-libev。首先安装依赖项目 12yum install epel-release -yyum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y shadowsocks-libev 托管在 dnf 的 copr 仓库内，默认的 centos7 是不带这个仓库。这里我们安装 dnf 和 copr 仓库。1. 安装 dnf 和 copr 仓库 123yum install dnfdnf install dnf-plugins-corednf install dnf-plugins-copr 2. 开启 copr 的shadowsocks-libev 1dnf copr enable librehat&#x2F;shadowsocks 3. 安装 shadowsocks-libev 12dnf updatednf install shadowsocks-libev 到此为止，如果没有出现什么问题，安装就算完成了，现在执行下面的命令来测试一下： 1ss-server -h 配置服务端参数上面说到，通过执行 ss-server 可以启动一个 ss 服务器，但是，在实际使用的时候，我们通常设置自己使用的参数，下面的例子是一组最简单的参数。 1ss-server -p 8989 -k 123456 -m chacha20 --fast-open 其中-p 是对外开放的端口，-k 是密码，-m 是加密方式，chacha20 是一种非常优秀的加密方式呦，你懂得。–fast-open 开启 TCP 快速打开模式。你可以直接在 VPS 的执行上面的命令，但是这是一个阻塞命令，我们可以使用 nohup 来切换到后台运行。 1nohup ss-server -p 8989 -k 123456 -m chacha20 --fast-open &amp; 看一下我们的 ss-server 是否启动成功 12# 通过pid查看ss是否启动ps -ef|grep ss-server 12# 通过端口查看ss是否启动iptables -xvn -L|grep 8989 别忘了防火墙在上面的参数中，ss 对外开放的端口是 8989。那么我们通过 Centos7 的 firewalld-cmd 防火墙放行这个端口。 123456systemctl enable firewalldfirewall-cmd --set-default-zone&#x3D;publicfirewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;sshfirewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;tcpfirewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;udpfirewall-cmd --reload 上面开启了 ssh 服务使用的端口和 8989 端口，如果你还有需要使用的端口，请参考这篇文章How To Set Up a Firewall Using FirewallD on CentOS 7好啦！测试一下我们的 8989 通不通吧，在本地电脑 telnet 到 8989 1telnet [domain name or ip] 8989 空白代表通了。 （未完待续）下一篇讲述怎么搭建客户端，以及一些小技巧。","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"Shadowsocks 实战教程全景实录（1）","slug":"Shadowsocks 实战教程全景实录（1）","date":"2019-06-08T20:36:46.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2019/06/08/Shadowsocks 实战教程全景实录（1）/","link":"","permalink":"https://lecon.io/2019/06/08/Shadowsocks%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%E5%85%A8%E6%99%AF%E5%AE%9E%E5%BD%95%EF%BC%881%EF%BC%89/","excerpt":"近些日子，很多同事都在说自己的代理又不能用了。有的被封 IP，有的 DNS 污染。万里长城在中美贸易战的的大情况下越来越坚固。秋大论坛也宣布告别，搬瓦工取消 29.9 美金的最低套餐，真是苦了我们这些普通程序员了，我们只想安安静静的学习一下国外程序员的经验。","text":"近些日子，很多同事都在说自己的代理又不能用了。有的被封 IP，有的 DNS 污染。万里长城在中美贸易战的的大情况下越来越坚固。秋大论坛也宣布告别，搬瓦工取消 29.9 美金的最低套餐，真是苦了我们这些普通程序员了，我们只想安安静静的学习一下国外程序员的经验。 首先这篇文章的定位是交给大家，怎么使用自己的 VPS 搭建 Shadowsock 服务器，网上的教程有很多，我自己也探了不少的坑，那么，就说下一我自己的经验。 VPS 提供商我的 VPS 选购的是搬瓦工，由于购买的比较早，每年只需 19.9 美金。现在最低是 49.9 美金，以我对搬瓦工这个尿性的了解，基本不会再恢复 29.9 的价位了。相比其他 VPS 提供商，每年 50 刀的价格也算比较良心的。而且这家提供商的机器真的是稳得一笔呀，很少有丢包的情况，基本日常工作可以满足。测速也可以把带宽跑到慢速，我家是 100Mb 宽带，下载速度在 10+MB/S 左右。 如果你跟着我的主线流程慢慢做，那么你也可以到达这个速度。 如果你和我一样，选择搬瓦工的话，那么在选择机房的时候，要选择 CN2 线路。到中国的延迟只有 160ms 左右（深圳），操作系统选择 Centos7。 注意，CN2 的线路只有 0.33x 的流量。比如说，如果你的机器是 500GB 每月，那么流量就变成 0.33 的倍数。 操作系统选择 Centos7，其他的系统我也都用过，但是这个是最稳定的，Centos6 也可以，但是软件都比较老，防火墙只能用 iptables。debian 和 ubuntu 在网路持续最大化的时候，可能会将 ss-server 进程杀死。 关于 bbr我推荐使用 bbr，关于是不是用，我说一个数据你就明白了。在没有使用 bbr 之前，我下载速度最多只有 40kb/s，使用字后可以到 300kb/s。当然，你也可以选择锐速，或者暴力魔改 bbr，我贴出一个切换 bbr 和锐速的链接，大家自己选择。若这里选择了 bbr，并且你也不愿意折腾，那么就不用关注这个链接。 1wget -N --no-check-certificate &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chiakge&#x2F;Linux-NetSpeed&#x2F;master&#x2F;tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; .&#x2F;tcp.sh 安装好系统之后，通过 ssh 接入机器。 （未完待续）下一篇讲述怎么搭建 Shadowsocks-libev 服务器，搭建完成之后，就可以使用 SS 的基本功能了！","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"破解公司 Mac 电脑的 jamf 限制，让 Mac 可以共享 Wifi","slug":"破解公司Mac的Wifi共享限制","date":"2019-06-05T16:49:06.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2019/06/05/破解公司Mac的Wifi共享限制/","link":"","permalink":"https://lecon.io/2019/06/05/%E7%A0%B4%E8%A7%A3%E5%85%AC%E5%8F%B8Mac%E7%9A%84Wifi%E5%85%B1%E4%BA%AB%E9%99%90%E5%88%B6/","excerpt":"一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。","text":"一般来说，公司的 Mac 计算机多多少少都会做一些限制，比如说：无法开始 Wifi ，无法使用 iCloud 等等。 这些功能的限制都是通过 Mac 的 jamf 管理的，破解限制需要 Root 权限。首先我们先找到 jamf 这个可执行文件，他一般在 /usr/local/jamf/ 下面。也可以通过 find 命令查找。 1234567find /usr/local |grep jamf/usr/local/bin/jamf/usr/local/bin/jamfAgent/usr/local/jamf/usr/local/jamf/bin/usr/local/jamf/bin/jamf 我的 jamf 可执行文件在 /usr/local/jamf/bin 下面。那么开始破解： 首先通过执行 1sudo jamf removeMDMProfile 移除 jamf 的限制，这时候受限制的功能就可以使用了。但是，过一段时间之后你会发现又恢复原来的状态了。那么应该怎么解决呢？我们做一个伪装的 jamf 吧！这时候系统调用 jamf 的时候，就会调用我们伪装的文件，不让我们的破解失效。 首先备份原始文件，这里要把整个 bin 目录备份。 123cd /usr/local/jamfmkdir backupmv bin backup 新建一个伪装 jamf 的纯文本文档，输入以下信息 12#!&#x2F;bin&#x2F;shecho &#39;dummy&#39; &gt; &#x2F;dev&#x2F;null 替换原有的 jamf 123mkdir &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;sudo mv jamf &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;chmod +x &#x2F;usr&#x2F;local&#x2F;jamf&#x2F;bin&#x2F;jamf 然后重启你的 Mac ，大功告成！","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"Godaddy 快速配置三级域名","slug":"快速配置三级域名","date":"2019-03-08T09:08:49.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2019/03/08/快速配置三级域名/","link":"","permalink":"https://lecon.io/2019/03/08/%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%89%E7%BA%A7%E5%9F%9F%E5%90%8D/","excerpt":"如何配置快速配置三级域名","text":"如何配置快速配置三级域名 一般我们使用 A 记录添加二级域名，如下图： ![](https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/屏幕快照 2019-03-08 09.14.11.png) 这条记录吧f.xxx.xxx解析到局域网10.118.60.71。 添加三级域名需要再加上一条 C 记录。如下图 ![](https://pics-1256269247.cos.ap-guangzhou.myqcloud.com/屏幕快照 2019-03-08 09.14.29.png) 这条记录吧xxx.f.xxx.xxx解析到上面的f.xxx.xxx地址，也就是10.118.60.71。","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]},{"title":"Centos7增加swap分区大小","slug":"Centos7增加swap分区大小","date":"2018-12-21T13:57:17.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2018/12/21/Centos7增加swap分区大小/","link":"","permalink":"https://lecon.io/2018/12/21/Centos7%E5%A2%9E%E5%8A%A0swap%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/","excerpt":"如何增加 Centos7 的 swap 分区大小","text":"如何增加 Centos7 的 swap 分区大小 1.添加 swap 分区dd if=/dev/zero of=/var/swapfile bs=1024 count=4096k 2.执行完毕，对交换文件格式化并转换为 swap 分区：mkswap /var/swapfile 3.挂载并激活分区：swapon /var/swapfile 4 赋权限chmod -R 0600 /var/swapfile 5.设置开机自动挂载该分区：vi /etc/fstab在 fstab 文件末尾追加如下内容后:wq!保存即可：/var/swapfile swap swap defaults 0 0","categories":[{"name":"黑洞","slug":"黑洞","permalink":"https://lecon.io/categories/%E9%BB%91%E6%B4%9E/"}],"tags":[]},{"title":"使用Caddy代理Bitbucket服务器","slug":"使用Caddy代理Bitbucket服务器","date":"2018-12-21T13:55:53.000Z","updated":"2021-03-04T00:34:20.165Z","comments":true,"path":"2018/12/21/使用Caddy代理Bitbucket服务器/","link":"","permalink":"https://lecon.io/2018/12/21/%E4%BD%BF%E7%94%A8Caddy%E4%BB%A3%E7%90%86Bitbucket%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。","text":"在这之前，一直玩 gitlab，gitlab 有一个好的地方就是他的 ci 功能。一个服务器既有了 git 管理又有了持续集成功能。但是 gitlab 安装门槛还算是比较高的，尤其是配置很多自定义的功能呢。贵在开源，随便折腾。 BitbucketBitbucket 虽然不是一个免费的版本管理工具，但是本身体验还是很好的，即使付费版本个人使用也很便宜。基于 Java 实现，执行效率当然说的过去。相比于 gitlab 这种需要内存至少 2G 的怪兽，至少是一个选择，而却他不容易宕机，但是他的最大魅力还是配置比较简单。 下载方式，官网找下载链接，直接 wget1https:&#x2F;&#x2F;bitbucket.org&#x2F;product&#x2F;download Caddy使用 Caddy 之前，一直使用 Nginx 作为反向代理服务器，但是 Nginx 配置比较复杂，本身又基于服务模式启动，对于玩家不太友好。Caddy 解决了这些问题，下载好，只需要要执行一个命令就可以启动服务器，全世界都能看到你了。主要是，他可以自动申请 ssl，免去自己申请。 下载方式：1curl https:&#x2F;&#x2F;getcaddy.com | bash -s personal 步骤Atlassian 家的软件启动都非常简单。下载好之后，给它一个可执行的权限，然后./他就可以了。 12chmod +x atlassian-bitbucket-5.16.0-x64.bin.&#x2F;atlassian-bitbucket-5.16.0-x64.bin 这个步骤最好给它 Root 权限。安装完成之后，在/opt下面你可以找到他。到bin目录下，启动它 12cd &#x2F;opt&#x2F;atlassian&#x2F;bitbucket&#x2F;5.16.0&#x2F;bin.&#x2F;start-bitbucket.sh 然后，访问youip:7990。现在大概可以配置这台 git 服务器了。一台电脑只有一个 80 或者 443 端口，不同的服务想使用同一个端口就需要反向代理服务器了。Caddy 需要一个 Caddyfile 文件，可以理解为 Caddy 的描述文件，随便创建一个目录，然后新建这个文件： 123mkdir -p ~&#x2F;wwwcd ~&#x2F;wwwvi Caddyfile 在这个文件中粘贴 123456789git.lecon.io &#123; proxy &#x2F; http:&#x2F;&#x2F;127.0.0.1:7990 &#123; header_upstream Host &#123;host&#125; header_upstream X-Real-IP &#123;remote&#125; header_upstream X-Forwarded-For &#123;remote&#125; header_upstream X-Forwarded-Server &#123;host&#125; header_upstream X-Forwarded-Proto &#123;scheme&#125; &#125;&#125; 意思大概就是说，把客户端的环境信息原封不动的发送给被代理对象。在当前 Caddyfile 目录中执行caddy。输入一下邮箱，现在访问你的网址，可以直接使用了。这个命令会阻塞当前 session，所以最好叫他到后台运行 1nohup caddy &amp; 跨域问题Caddy 会默认把 http 流量转发到 https 上，给客户端发送一个 302，重定向到 https 网址，这样的话就会出现一个问题，我在打开 Bitbucket 网页，然后请求外部网页，就会发生跨域问题，导致 Webhook 功能不能使用。现在需要配置一下 Bitbucket，找到bitbucket.properties 1find &#x2F;|grep bitbucket.properties 然后加入下面内容 12345server.port&#x3D;7990server.secure&#x3D;trueserver.scheme&#x3D;httpsserver.proxy-port&#x3D;443server.proxy-name&#x3D;git.lecon.io 重启一下 Bitbucket 服务器，Webhook 等功能可以正常使用。","categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"}],"tags":[]}],"categories":[{"name":"玩儿","slug":"玩儿","permalink":"https://lecon.io/categories/%E7%8E%A9%E5%84%BF/"},{"name":"黑洞","slug":"黑洞","permalink":"https://lecon.io/categories/%E9%BB%91%E6%B4%9E/"}],"tags":[]}